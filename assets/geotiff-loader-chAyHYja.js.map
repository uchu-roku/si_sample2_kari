{"version":3,"mappings":"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","names":["_gtP","getGeotiff","__vitePreload","_p4P","getProj4","n","m","loadGeoTiffAsOverlay","buf","signal","forcedCrs","worldFile","fromArrayBuffer","Pool","tiff","img","ovs","PREVIEW_MAX","w0","h0","s","w","h","pool","raster","canvas","ctx","imageData","d","i","j","v","blob","r","url","__urls","revoke","u","bbox","crs","minX","minY","maxX","maxY","inLonLat","inMerc","tfw","parseTfw","latlngBounds","L","proj4","sw","ne","layer","imgFull","fw","fh","pool2","rasFull","cv2","cx2","id2","blob2","fullUrl","e","text","lines","A","D","B","E","C","F","normalizeBand","arr","min","max","denom","pickCoarsestOverview","image","rgbaToBlobUrl","options","useOverview","previewMaxPixels","window","W","H","hasOv","report","readOpts","data","step","width","height","samples","bits","isByte","b","src","N","needNormalize","normalizeChannel","chanIndex","chStats","_","c","out","p","si","s0","s1","s2","g","a","res","makeRgbaBlobUrl","loadFile","file","fileExtension","loadGeoTIFF","loadGeoPackage","loadShapefile","input","arrayBuffer","raise","ERR","base","info","rasters","summary","statsOf","bounds","loadGeoTIFFFromArrayBuffer","metadata","geoKeys","targetImage","dataUrl","boundsLatLng","createRGBAImageFromGeoTIFF","overviews","ov","overviewCount","overview","error","loadCOGRange","selectOverviewByResolution","resolution","selectedOverview","minDiff","diff","createCanvasFromGeoTIFF","geoTiffData","band","nodataRaw","nodata","norm","R","G","hasAlpha","len","px","hasND","band1","span","allNoData","imageDataFromCanvas","raw","tmp","MAX_EDGE","finalCanvas","scale","c2","computeLatLngBounds","mercToLonLat","x","y","lon","lat","maxLat","looksLike3857BBox","bboxToLatLngBounds","epsg","west","south","east","north","tie","gk","loadGeoTIFFWithSteps","keys","epsgCode","loadGeoTIFFFromFileData"],"ignoreList":[],"sources":["../../src/geotiff-loader.js"],"sourcesContent":["import { ERR, raise, report, step, statsOf } from './errors.js';\r\nimport L from 'leaflet';\r\nlet _gtP; const getGeotiff = () => _gtP ||= import('geotiff');\r\nlet _p4P; const getProj4   = () => _p4P ||= import('proj4').then(m => m.default || m);\r\n\r\n// 返り値：{ ok:true, layer, bounds, revoke } または { ok:false, reason:'NEED_CRS', suggestion?: '4326'|'3857' }\r\nexport async function loadGeoTiffAsOverlay(buf, { signal, forcedCrs = null, worldFile = null } = {}) {\r\n  if (signal?.aborted) throw new DOMException('Aborted','AbortError');\r\n  // Pool も取り出す（並列デコード）\r\n  const { fromArrayBuffer, Pool } = await getGeotiff();\r\n  const tiff = await fromArrayBuffer(buf);\r\n  if (signal?.aborted) throw new DOMException('Aborted','AbortError');\r\n  // まず最も粗いオーバービュー（なければ0番）を選ぶ\r\n  let img = await tiff.getImage();\r\n  try {\r\n    const ovs = img.getOverviews?.();\r\n    if (ovs && ovs.length) img = ovs[ovs.length - 1];\r\n  } catch {}\r\n  if (signal?.aborted) throw new DOMException('Aborted','AbortError');\r\n\r\n  // === プレビュー生成（最大辺 2048px・nearest・並列）=========================\r\n  const PREVIEW_MAX = 2048;\r\n  const w0 = img.getWidth(), h0 = img.getHeight();\r\n  const s  = Math.min(1, PREVIEW_MAX / Math.max(w0, h0));\r\n  const w  = Math.max(1, Math.floor(w0 * s));\r\n  const h  = Math.max(1, Math.floor(h0 * s));\r\n  const pool = new Pool(Math.min(8, navigator.hardwareConcurrency || 4));\r\n  const raster = await img.readRasters({\r\n    interleave: true, width: w, height: h, resampleMethod: 'nearest', pool\r\n  });\r\n  try { pool.terminate?.(); } catch {}\r\n  if (signal?.aborted) throw new DOMException('Aborted','AbortError');\r\n\r\n  // PNG Blob（プレビュー）\r\n  const canvas = document.createElement('canvas');\r\n  canvas.width = w; canvas.height = h;\r\n  const ctx = canvas.getContext('2d');\r\n  const imageData = new ImageData(w, h);\r\n  // RGBA 想定：足りなければアルファ255で埋める\r\n  if (raster.length === w * h * 4) {\r\n    imageData.data.set(raster);\r\n  } else if (raster.length === w * h * 3) {\r\n    const d = imageData.data;\r\n    for (let i=0,j=0; i<raster.length; i+=3, j+=4) {\r\n      d[j]=raster[i]; d[j+1]=raster[i+1]; d[j+2]=raster[i+2]; d[j+3]=255;\r\n    }\r\n  } else {\r\n    // 単バンドなどは簡易グレイスケール\r\n    const d = imageData.data;\r\n    for (let i=0,j=0; i<w*h; i++, j+=4) {\r\n      const v = raster[i] ?? 0;\r\n      d[j]=v; d[j+1]=v; d[j+2]=v; d[j+3]=255;\r\n    }\r\n  }\r\n  ctx.putImageData(imageData, 0, 0);\r\n  const blob = await new Promise(r => canvas.toBlob(r, 'image/png'));\r\n  const url = URL.createObjectURL(blob);\r\n  const __urls = [url];\r\n  const revoke = () => { try { __urls.forEach(u => URL.revokeObjectURL(u)); } catch {} };\r\n\r\n  // 1) bbox を取得できるか試す\r\n  let bbox = null;\r\n  try { bbox = img.getBoundingBox(); } catch {}\r\n\r\n  // 2) CRS 判定／強制\r\n  let crs = forcedCrs; // 'EPSG:4326' | 'EPSG:3857' | null\r\n  if (!crs) {\r\n    if (bbox) {\r\n      const [minX,minY,maxX,maxY] = bbox;\r\n      const inLonLat = Math.max(Math.abs(minX),Math.abs(maxX)) <= 180 && Math.max(Math.abs(minY),Math.abs(maxY)) <= 90;\r\n      const inMerc   = Math.max(Math.abs(minX),Math.abs(maxX)) > 180 && Math.max(Math.abs(minY),Math.abs(maxY)) > 90 &&\r\n                       Math.max(Math.abs(minX),Math.abs(maxX)) <= 20040000 && Math.max(Math.abs(minY),Math.abs(maxY)) <= 20040000;\r\n      if (inLonLat) crs = 'EPSG:4326';\r\n      else if (inMerc) crs = 'EPSG:3857';\r\n    }\r\n  }\r\n\r\n  // 3) bbox が無い場合は WorldFile から推定（回転0前提: B=D=0）\r\n  if (!bbox && worldFile) {\r\n    const tfw = parseTfw(worldFile);\r\n    if (tfw && Math.abs(tfw.B) < 1e-9 && Math.abs(tfw.D) < 1e-9) {\r\n      // A: pixel size X、E: -pixel size Y、C,F: 左上座標\r\n      const minX = tfw.C;\r\n      const maxY = tfw.F;\r\n      const maxX = minX + tfw.A * w;\r\n      const minY = maxY + tfw.E * h; // E は負数想定\r\n      bbox = [minX, minY, maxX, maxY];\r\n      // TFWに対しても CRS 必須\r\n      crs = crs || 'EPSG:4326'; // デフォルトは WGS84 とみなす（UIで 3857 を選べば forcedCrs で上書き）\r\n    }\r\n  }\r\n\r\n  if (!bbox || !crs) {\r\n    revoke();\r\n    return { ok:false, reason:'NEED_CRS', suggestion: bbox ? '3857' : undefined };\r\n  }\r\n\r\n  // 4) Leaflet bounds（必ず 4326 に正規化）\r\n  let latlngBounds;\r\n  if (crs === 'EPSG:4326') {\r\n    const [minX,minY,maxX,maxY] = bbox;\r\n    latlngBounds = L.latLngBounds([minY,minX],[maxY,maxX]);\r\n  } else if (crs === 'EPSG:3857') {\r\n    const [minX,minY,maxX,maxY] = bbox;\r\n    const proj4 = await getProj4();\r\n    const sw = proj4('EPSG:3857','EPSG:4326',[minX,minY]);\r\n    const ne = proj4('EPSG:3857','EPSG:4326',[maxX,maxY]);\r\n    latlngBounds = L.latLngBounds([sw[1],sw[0]],[ne[1],ne[0]]);\r\n  } else {\r\n    revoke();\r\n    return { ok:false, reason:`CRS ${crs} is not supported in P1` };\r\n  }\r\n\r\n  const layer = L.imageOverlay(url, latlngBounds, { opacity: 0.9, pane: 'overlayPane' });\r\n\r\n  // === バックグラウンドでフル解像に差し替え ================================\r\n  queueMicrotask(async () => {\r\n    try {\r\n      const imgFull = await tiff.getImage(); // 0番（フル解像）\r\n      const fw = imgFull.getWidth(), fh = imgFull.getHeight();\r\n      const pool2 = new Pool(Math.min(8, navigator.hardwareConcurrency || 4));\r\n      const rasFull = await imgFull.readRasters({ interleave: true, pool: pool2 });\r\n      try { pool2.terminate?.(); } catch {}\r\n      const cv2 = document.createElement('canvas');\r\n      cv2.width = fw; cv2.height = fh;\r\n      const cx2 = cv2.getContext('2d');\r\n      const id2 = new ImageData(fw, fh);\r\n      if (rasFull.length === fw*fh*4) {\r\n        id2.data.set(rasFull);\r\n      } else if (rasFull.length === fw*fh*3) {\r\n        const d = id2.data; for (let i=0,j=0; i<rasFull.length; i+=3, j+=4) {\r\n          d[j]=rasFull[i]; d[j+1]=rasFull[i+1]; d[j+2]=rasFull[i+2]; d[j+3]=255;\r\n        }\r\n      } else {\r\n        const d = id2.data; for (let i=0,j=0; i<fw*fh; i++, j+=4) {\r\n          const v = rasFull[i] ?? 0; d[j]=v; d[j+1]=v; d[j+2]=v; d[j+3]=255;\r\n        }\r\n      }\r\n      cx2.putImageData(id2, 0, 0);\r\n      const blob2 = await new Promise(r => cv2.toBlob(r, 'image/png'));\r\n      const fullUrl = URL.createObjectURL(blob2);\r\n      try { __urls.push(fullUrl); } catch {}\r\n      try { layer.setUrl(fullUrl); } catch {}\r\n      try { URL.revokeObjectURL(url); } catch {}\r\n    } catch (e) {\r\n      console.warn('[GeoTIFF] full-res swap failed:', e);\r\n    }\r\n  });\r\n\r\n  return { ok:true, layer, bounds: latlngBounds, revoke };\r\n}\r\n\r\nfunction parseTfw(text) {\r\n  try {\r\n    const lines = (text || '').trim().split(/\\r?\\n/).map(s => parseFloat(s.trim()));\r\n    if (lines.length < 6 || lines.some(n => Number.isNaN(n))) return null;\r\n    const [A, D, B, E, C, F] = lines; // 6行の順序に注意（業界慣習）\r\n    return { A, D, B, E, C, F };\r\n  } catch {\r\n    return null;\r\n  }\r\n}\r\n\r\n// ✅ hoistedな関数宣言にして、minify後も\"定義前参照\"を回避\r\nfunction normalizeBand(arr){\r\n  let min = Infinity, max = -Infinity;\r\n  for (let i = 0; i < arr.length; i++){\r\n    const v = arr[i];\r\n    if (Number.isFinite(v)){ if (v < min) min = v; if (v > max) max = v; }\r\n  }\r\n  if (!Number.isFinite(min) || !Number.isFinite(max) || min === max){ min = 0; max = 1; }\r\n  const denom = (max - min) || 1;\r\n  return function(v){\r\n    if (!Number.isFinite(v)) return 0;\r\n    const n = ((v - min) / denom) * 255;\r\n    return n < 0 ? 0 : n > 255 ? 255 : n;\r\n  };\r\n}\r\n\r\n/**\r\n * v1/v2両対応で最も粗いオーバービュー（軽量表示）を取得\r\n * @param {Object} image - GeoTIFFイメージ\r\n * @returns {Promise<Object>} オーバービューまたは元のイメージ\r\n */\r\nasync function pickCoarsestOverview(image){\r\n  if (typeof image.getOverviews === 'function'){               // v2\r\n    const ovs = await image.getOverviews();\r\n    return (ovs && ovs.length) ? ovs[ovs.length - 1] : image;\r\n  }\r\n  if (typeof image.getOverviewCount === 'function'             // v1\r\n   && typeof image.getOverview === 'function'){\r\n    const n = image.getOverviewCount();\r\n    return (n && n > 0) ? image.getOverview(n - 1) : image;\r\n  }\r\n  return image;\r\n}\r\n\r\n/**\r\n * RGBA → Blob URL 生成\r\n * options:\r\n *  - useOverview: true なら最も低解像度オーバービューで描画（高速プレビュー）\r\n *  - previewMaxPixels: しきい値（例: 1e6）を超える場合はオーバービューを選択\r\n *  - window: [xmin, ymin, xmax, ymax] ピクセル座標で部分読み出し（COG前提で高速）\r\n */\r\nexport async function rgbaToBlobUrl(image, options = {}) {\r\n  const { useOverview = false, previewMaxPixels = 1_000_000, window = null } = options;\r\n  let img = image;\r\n  try {\r\n    const W = image.getWidth(), H = image.getHeight();\r\n    const hasOv = typeof image.getOverviews === 'function' && image.getOverviews().length > 0;\r\n    if ((useOverview || W * H > previewMaxPixels) && hasOv) {\r\n      const ovs = image.getOverviews();\r\n      img = ovs[ovs.length - 1]; // 最も低解像度\r\n      report({ phase: 'overview-picked', size: [img.getWidth(), img.getHeight()] }, 'info');\r\n    }\r\n  } catch {}\r\n\r\n  // readRasters の窓読み（COGなら速い）\r\n  const readOpts = { interleave: true };\r\n  if (window && Array.isArray(window) && window.length === 4) readOpts.window = window;\r\n\r\n  const data = await step('geotiff.readRasters', () => img.readRasters(readOpts));\r\n  const width = img.getWidth(), height = img.getHeight();\r\n\r\n  // ===== ここから：どのチャンネル数でも RGBA に組み立てる =====\r\n  const samples = (img.getSamplesPerPixel?.() ?? img.fileDirectory?.SamplesPerPixel ?? 1);\r\n  const bits    = (img.getBitsPerSample?.() ?? img.fileDirectory?.BitsPerSample ?? [8]);\r\n  const isByte  = Array.isArray(bits) ? bits.every(b => b === 8) : bits === 8;\r\n\r\n  // data は interleave:true のため、長さは width*height*samples\r\n  const src = data; // TypedArray\r\n  const N   = width * height;\r\n  // 8bit 以外（UInt16/Float等）の場合は 0..255 に正規化\r\n  const needNormalize = !isByte || !(src instanceof Uint8Array || src instanceof Uint8ClampedArray);\r\n\r\n  // 簡易正規化（各チャンネルごとに min-max スケーリング）\r\n  function normalizeChannel(chanIndex) {\r\n    if (!needNormalize) return { min: 0, max: 255 };\r\n    let min = Infinity, max = -Infinity;\r\n    for (let i = chanIndex; i < src.length; i += samples) {\r\n      const v = src[i];\r\n      if (v < min) min = v;\r\n      if (v > max) max = v;\r\n    }\r\n    if (min === max) { // 定数面は白で\r\n      min = 0; max = 1;\r\n    }\r\n    return { min, max };\r\n  }\r\n  const chStats = Array.from({ length: samples }, (_, c) => normalizeChannel(c));\r\n\r\n  const out = new Uint8ClampedArray(N * 4);\r\n  // サンプル数に応じた合成\r\n  if (samples === 4) {\r\n    // 想定：RGBA（あるいはRGB+Alpha）。順番そのまま入れる\r\n    for (let p = 0, si = 0; p < N; p++, si += 4) {\r\n      for (let c = 0; c < 4; c++) {\r\n        const { min, max } = chStats[c];\r\n        const v = src[si + c];\r\n        out[p * 4 + c] = needNormalize ? ((v - min) * 255) / (max - min) : v;\r\n      }\r\n    }\r\n  } else if (samples === 3) {\r\n    // RGB → RGBA（A=255）\r\n    const s0 = chStats[0], s1 = chStats[1], s2 = chStats[2];\r\n    for (let p = 0, si = 0; p < N; p++, si += 3) {\r\n      out[p*4]   = needNormalize ? ((src[si]   - s0.min) * 255) / (s0.max - s0.min) : src[si];\r\n      out[p*4+1] = needNormalize ? ((src[si+1] - s1.min) * 255) / (s1.max - s1.min) : src[si+1];\r\n      out[p*4+2] = needNormalize ? ((src[si+2] - s2.min) * 255) / (s2.max - s2.min) : src[si+2];\r\n      out[p*4+3] = 255;\r\n    }\r\n  } else if (samples === 2) {\r\n    // 想定：Gray + Alpha\r\n    const s0 = chStats[0], s1 = chStats[1];\r\n    for (let p = 0, si = 0; p < N; p++, si += 2) {\r\n      const g = needNormalize ? ((src[si] - s0.min) * 255) / (s0.max - s0.min) : src[si];\r\n      const a = needNormalize ? ((src[si+1] - s1.min) * 255) / (s1.max - s1.min) : src[si+1];\r\n      out[p*4] = out[p*4+1] = out[p*4+2] = g;\r\n      out[p*4+3] = a;\r\n    }\r\n  } else if (samples === 1) {\r\n    // Gray → RGBA（A=255）\r\n    const s0 = chStats[0];\r\n    for (let p = 0; p < N; p++) {\r\n      const v = needNormalize ? ((src[p] - s0.min) * 255) / (s0.max - s0.min) : src[p];\r\n      out[p*4] = out[p*4+1] = out[p*4+2] = v;\r\n      out[p*4+3] = 255;\r\n    }\r\n  } else {\r\n    // 非想定（5バンド以上など）は最初の3つをRGB、A=255にする\r\n    const s0 = chStats[0] ?? {min:0,max:255};\r\n    const s1 = chStats[1] ?? s0;\r\n    const s2 = chStats[2] ?? s1;\r\n    for (let p = 0, si = 0; p < N; p++, si += samples) {\r\n      out[p*4]   = needNormalize ? ((src[si]   - s0.min) * 255) / (s0.max - s0.min) : src[si];\r\n      out[p*4+1] = needNormalize ? ((src[si+1] - s1.min) * 255) / (s1.max - s1.min) : src[si+1];\r\n      out[p*4+2] = needNormalize ? ((src[si+2] - s2.min) * 255) / (s2.max - s2.min) : src[si+2];\r\n      out[p*4+3] = 255;\r\n    }\r\n  }\r\n  // ===== ここまで：RGBA 組み立て =====\r\n\r\n  // Canvas → Blob → URL\r\n  const canvas = document.createElement('canvas');\r\n  canvas.width = width; canvas.height = height;\r\n  const ctx = canvas.getContext('2d', { willReadFrequently: false });\r\n  const imageData = new ImageData(out, width, height);\r\n  ctx.putImageData(imageData, 0, 0);\r\n  const blob = await new Promise(res => canvas.toBlob(res, 'image/png'));\r\n  return URL.createObjectURL(blob);\r\n}\r\n\r\n// 互換エクスポート\r\nexport const makeRgbaBlobUrl = rgbaToBlobUrl;\r\nexport default rgbaToBlobUrl;\r\n\r\n/**\r\n * ファイルを読み込む関数\r\n * @param {File} file - 読み込むファイル\r\n * @returns {Promise<Object>} ファイルデータ\r\n */\r\nexport async function loadFile(file) {\r\n  const fileExtension = file.name.split('.').pop().toLowerCase();\r\n  \r\n  switch (fileExtension) {\r\n    case 'tif':\r\n    case 'tiff':\r\n    case 'geotiff':\r\n      return await loadGeoTIFF(file);\r\n    case 'gpkg':\r\n      return await loadGeoPackage(file);\r\n    case 'shp':\r\n      return await loadShapefile(file);\r\n    default:\r\n      throw new Error(`サポートされていないファイル形式: ${fileExtension}`);\r\n  }\r\n}\r\n\r\n/**\r\n * GeoTIFF/COGファイルを読み込む関数\r\n * @param {File} file - 読み込むGeoTIFFファイル\r\n * @returns {Promise<Object>} GeoTIFFイメージデータ\r\n */\r\nexport async function loadGeoTIFF(input) {\r\n  try {\r\n    // 1) ArrayBuffer 化\r\n    const arrayBuffer = await step('read.arrayBuffer', async () => {\r\n      if (input instanceof ArrayBuffer) return input;\r\n      if (input instanceof Blob) return await input.arrayBuffer();\r\n      if (input?.buffer instanceof ArrayBuffer) return input.buffer;\r\n      throw raise(ERR.GEO_OPEN, 'サポートされない入力型です', { type: Object.prototype.toString.call(input) });\r\n    });\r\n    console.info('buffer bytes:', arrayBuffer.byteLength.toLocaleString());\r\n\r\n    // 2) GeoTIFF パース\r\n    const tiff = await step('geotiff.fromArrayBuffer', async () => {\r\n      try { return await fromArrayBuffer(arrayBuffer); }\r\n      catch (e) { throw raise(ERR.GEO_PARSE, 'geotiff.fromArrayBuffer() に失敗', { size: arrayBuffer.byteLength }, e); }\r\n    });\r\n\r\n    // 3) 画像選択（getImage / getOverviews）\r\n    const base = await step('geotiff.getImage', async () => {\r\n      try { return await tiff.getImage(); }\r\n      catch (e) { throw raise(ERR.GEO_GET_IMAGE, 'getImage() に失敗', {}, e); }\r\n    });\r\n    const info = {\r\n      width: base.getWidth?.(),\r\n      height: base.getHeight?.(),\r\n      bbox: base.getBoundingBox?.(),\r\n      srs: base.getGeoKeys?.(),\r\n      samples: base.getSamplesPerPixel?.(),\r\n      bits: base.getBitsPerSample?.(),\r\n      planar: base.getPlanarConfiguration?.(),\r\n      hasOverviews: typeof base.getOverviews === 'function',\r\n    };\r\n    console.groupCollapsed('ℹ️ GeoTIFF image info'); console.table(info); console.groupEnd();\r\n\r\n    const image = await step('geotiff.pickOverview', async () => {\r\n      try {\r\n        if (typeof base.getOverviews === 'function') {\r\n          const ovs = await base.getOverviews();\r\n          console.info('overview count:', ovs?.length || 0);\r\n          if (ovs && ovs.length) return ovs[0];\r\n        }\r\n        return base;\r\n      } catch (e) {\r\n        throw raise(ERR.GEO_PICK_OV, 'オーバービュー取得に失敗', {}, e);\r\n      }\r\n    });\r\n\r\n    // 4) ピクセル読取\r\n    const rasters = await step('geotiff.readRasters', async () => {\r\n      try {\r\n        return await image.readRasters({ interleave: false });\r\n      } catch (e) {\r\n        throw raise(ERR.GEO_RASTERS, 'readRasters() に失敗', {\r\n          width: image.getWidth?.(), height: image.getHeight?.(),\r\n          samples: image.getSamplesPerPixel?.(),\r\n        }, e);\r\n      }\r\n    });\r\n    // 代表統計\r\n    const summary = Array.from(rasters).slice(0, 3).map((r, i) => ({ band: i, ...statsOf(r) }));\r\n    console.groupCollapsed('📈 raster stats (first 3 bands)'); console.table(summary); console.groupEnd();\r\n\r\n    // 5) RGBA 化 → BlobURL\r\n    const { url, bounds } = await step('render.rgbaToBlobUrl', async () => {\r\n      return await rgbaToBlobUrl(image, rasters);\r\n    });\r\n\r\n    return { url, bounds };\r\n  } catch (e) {\r\n    report(e);\r\n    throw e; // 呼び出し側にも伝播\r\n  }\r\n}\r\n\r\n/**\r\n * GeoTIFF/COGファイルをArrayBufferから読み込む関数\r\n * @param {ArrayBuffer} arrayBuffer - GeoTIFFデータのArrayBuffer\r\n * @returns {Promise<Object>} GeoTIFFイメージデータ\r\n */\r\nexport async function loadGeoTIFFFromArrayBuffer(arrayBuffer) {\r\n  try {\r\n    // GeoTIFFとして解析\r\n    const tiff = await fromArrayBuffer(arrayBuffer);\r\n    \r\n    // 画像のメタデータを取得\r\n    const image = await tiff.getImage();\r\n    const metadata = image.getFileDirectory();\r\n    const geoKeys = image.getGeoKeys();\r\n    \r\n    // 画像データを取得\r\n    // 既定はフル解像度の一枚目\r\n    // 軽量表示：最も粗いオーバービューを使う（v1/v2両対応）\r\n    const targetImage = await pickCoarsestOverview(image);\r\n    \r\n    // 大きな画像の場合はダウンサンプリング\r\n    const readOpts = { interleave: false };\r\n    if (targetImage === image && typeof image.getWidth === 'function') {\r\n      const w = image.getWidth(), h = image.getHeight();\r\n      const max = 4096;\r\n      if (Math.max(w, h) > max) {\r\n        if (w >= h) {\r\n          readOpts.width = max;\r\n        } else {\r\n          readOpts.height = max;\r\n        }\r\n      }\r\n    }\r\n    const imageData = await targetImage.readRasters(readOpts);\r\n    \r\n    // RGBA化処理\r\n    const { dataUrl, boundsLatLng } = await createRGBAImageFromGeoTIFF(imageData, image, targetImage.getWidth(), targetImage.getHeight());\r\n    \r\n    // オーバービュー情報を取得\r\n    let overviews = [];\r\n    try {\r\n      if (typeof image.getOverviews === 'function') {\r\n        const ovs = await image.getOverviews(); // v2\r\n        overviews = ovs.map(ov => ({\r\n          width: ov.getWidth(),\r\n          height: ov.getHeight(),\r\n          scale: image.getWidth() / ov.getWidth()\r\n        }));\r\n      } else if (typeof image.getOverviewCount === 'function' && typeof image.getOverview === 'function') {\r\n        const overviewCount = image.getOverviewCount(); // v1\r\n        for (let i = 0; i < overviewCount; i++) {\r\n          const overview = await image.getOverview(i);\r\n          overviews.push({\r\n            width: overview.getWidth(),\r\n            height: overview.getHeight(),\r\n            scale: image.getWidth() / overview.getWidth()\r\n          });\r\n        }\r\n      }\r\n    } catch (error) {\r\n      console.warn('オーバービュー情報の取得に失敗しました:', error);\r\n      overviews = [];\r\n    }\r\n    \r\n    return {\r\n      type: 'geotiff',\r\n      tiff,\r\n      image,\r\n      metadata,\r\n      geoKeys,\r\n      imageData,\r\n      width: targetImage.getWidth(),\r\n      height: targetImage.getHeight(),\r\n      bbox: targetImage.getBoundingBox(),\r\n      boundsLatLng, // 追加\r\n      overviews,\r\n      isCog: overviews.length > 0,\r\n      dataUrl // 追加\r\n    };\r\n  } catch (error) {\r\n    console.error('GeoTIFFの読み込みエラー:', error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n/**\r\n * GeoPackageファイルを読み込む関数\r\n * @param {File} file - 読み込むGeoPackageファイル\r\n * @returns {Promise<Object>} GeoPackageデータ\r\n */\r\nexport async function loadGeoPackage(file) {\r\n  try {\r\n    // ファイルをArrayBufferとして読み込む\r\n    const arrayBuffer = await file.arrayBuffer();\r\n    \r\n    // ここでは簡単な例として、ファイルの基本情報を返す\r\n    // 実際の実装では、GeoPackageの解析ライブラリを使用してデータを読み込む\r\n    return {\r\n      type: 'geopackage',\r\n      fileName: file.name,\r\n      fileSize: file.size,\r\n      // 実際のGeoPackageデータ解析はここに実装\r\n    };\r\n  } catch (error) {\r\n    console.error('GeoPackageの読み込みエラー:', error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n/**\r\n * Shapefileを読み込む関数\r\n * @param {File} file - 読み込むShapefile\r\n * @returns {Promise<Object>} Shapefileデータ\r\n */\r\nexport async function loadShapefile(file) {\r\n  try {\r\n    // ファイルをArrayBufferとして読み込む\r\n    const arrayBuffer = await file.arrayBuffer();\r\n    \r\n    // ここでは簡単な例として、ファイルの基本情報を返す\r\n    // 実際の実装では、Shapefileの解析ライブラリを使用してデータを読み込む\r\n    return {\r\n      type: 'shapefile',\r\n      fileName: file.name,\r\n      fileSize: file.size,\r\n      // 実際のShapefileデータ解析はここに実装\r\n    };\r\n  } catch (error) {\r\n    console.error('Shapefileの読み込みエラー:', error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n/**\r\n * COGの特定の範囲を読み込む関数\r\n * @param {GeoTIFF} tiff - GeoTIFFオブジェクト\r\n * @param {Object} options - 読み込みオプション\r\n * @returns {Promise<Object>} 画像データ\r\n */\r\nexport async function loadCOGRange(tiff, options = {}) {\r\n  try {\r\n    const image = await tiff.getImage(options);\r\n    const imageData = await image.readRasters(options);\r\n    \r\n    return {\r\n      image,\r\n      imageData,\r\n      width: image.getWidth(),\r\n      height: image.getHeight(),\r\n      bbox: image.getBoundingBox()\r\n    };\r\n  } catch (error) {\r\n    console.error('COG範囲読み込みエラー:', error);\r\n    throw error;\r\n  }\r\n}\r\n\r\n/**\r\n * 解像度に基づいて適切なオーバービューを選択\r\n * @param {Array} overviews - オーバービュー情報の配列\r\n * @param {number} resolution - 要求解像度\r\n * @returns {Object|null} 適切なオーバービュー情報\r\n */\r\nexport function selectOverviewByResolution(overviews, resolution) {\r\n  if (!overviews || overviews.length === 0) return null;\r\n  \r\n  // 要求解像度に最も近いオーバービューを選択\r\n  let selectedOverview = overviews[0];\r\n  let minDiff = Math.abs(resolution - selectedOverview.scale);\r\n  \r\n  for (let i = 1; i < overviews.length; i++) {\r\n    const diff = Math.abs(resolution - overviews[i].scale);\r\n    if (diff < minDiff) {\r\n      minDiff = diff;\r\n      selectedOverview = overviews[i];\r\n    }\r\n  }\r\n  \r\n  return selectedOverview;\r\n}\r\n\r\n/**\r\n * GeoTIFFデータからキャンバスイメージを作成\r\n * @param {Object} geoTiffData - GeoTIFFデータ\r\n * @returns {HTMLCanvasElement} キャンバス要素\r\n */\r\nexport async function createCanvasFromGeoTIFF(geoTiffData) {\r\n  const { width, height, imageData, image } = geoTiffData;\r\n \r\n  // キャンバスを作成\r\n  const canvas = document.createElement('canvas');\r\n  canvas.width = width;\r\n  canvas.height = height;\r\n  const ctx = canvas.getContext('2d');\r\n \r\n  // 画像データをキャンバスに描画（RGB または グレースケール）\r\n  if (imageData && imageData.length) {\r\n    // グレースケール（1バンド）の場合\r\n    if (imageData.length === 1) {\r\n      const band = imageData[0];\r\n      const out = ctx.createImageData(width, height);\r\n      \r\n      // NoData 値の取得と処理\r\n      const nodataRaw = image.getGDALNoData ? await image.getGDALNoData() : undefined;\r\n      const nodata = nodataRaw !== undefined && nodataRaw !== null && nodataRaw !== '' ? Number(nodataRaw) : undefined;\r\n      const norm = normalizeBand(band);\r\n      \r\n      for (let i=0;i<band.length;i++){\r\n        const v = band[i];\r\n        const p = i<<2;\r\n        if (nodata !== undefined && Number.isFinite(nodata) && v === nodata){\r\n          out.data[p+3] = 0;              // NoData は完全に透明\r\n          continue;\r\n        }\r\n        const g = norm(v)|0;\r\n        out.data[p] = out.data[p+1] = out.data[p+2] = g;\r\n        out.data[p+3] = 255;              // 可視化する画素は不透明\r\n      }\r\n      ctx.putImageData(out, 0, 0);\r\n    } else {\r\n      // RGB(A)（3〜4バンド）の場合\r\n      const R=imageData[0], G=imageData[1], B=imageData[2], A=imageData[3];\r\n      const hasAlpha = imageData.length===4;\r\n      const nodataRaw = image.getGDALNoData ? await image.getGDALNoData() : undefined;\r\n      const nodata = nodataRaw !== undefined && nodataRaw !== null && nodataRaw !== '' ? Number(nodataRaw) : undefined;\r\n      const len = R.length;\r\n      const out = ctx.createImageData(width, height);\r\n      \r\n      for (let i=0;i<len;i++){\r\n        const p=i<<2;\r\n        if (nodata !== undefined && Number.isFinite(nodata) && (R[i]===nodata || G[i]===nodata || B[i]===nodata)){\r\n          out.data[p+3]=0;               // NoData は透明\r\n          continue;\r\n        }\r\n        out.data[p]=R[i]; out.data[p+1]=G[i]; out.data[p+2]=B[i];\r\n        out.data[p+3]=hasAlpha ? A[i] : 255; // 不透明で重ねる\r\n      }\r\n      ctx.putImageData(out, 0, 0);\r\n    }\r\n  } else {\r\n    // デフォルトの表示（テスト用）\r\n    ctx.fillStyle = '#8bc34a';\r\n    ctx.fillRect(0, 0, width, height);\r\n  }\r\n \r\n  return canvas;\r\n}\r\n\r\nfunction detectProj4Def(image){\r\n  const gk = image.getGeoKeys ? image.getGeoKeys() : {};\r\n  const pcs = gk?.ProjectedCSTypeGeoKey;      // 例: 32654 = UTM zone 54N (WGS84)\r\n  const gcs = gk?.GeographicTypeGeoKey;       // 4326 / 4612(JGD2000) / 6668(JGD2011) など\r\n  const cit = gk?.PCSCitationGeoKey || gk?.GeogCitationGeoKey || '';\r\n  // 経緯度系（WGS84/JGD）は 4326 相当として扱う（数m差は実務上許容）\r\n  if (gcs === 4326 || gcs === 4612 || gcs === 6668) return 'EPSG:4326';\r\n  if (pcs === 4326) return 'EPSG:4326';\r\n  // UTM (WGS84) の典型\r\n  if (pcs >= 32601 && pcs <= 32660){ const zone = pcs - 32600; return `+proj=utm +zone=${zone} +datum=WGS84 +units=m +no_defs`; }\r\n  if (pcs >= 32701 && pcs <= 32760){ const zone = pcs - 32700; return `+proj=utm +zone=${zone} +south +datum=WGS84 +units=m +no_defs`; }\r\n  // 引用文字列から \"zone 54N\" のような表記を拾う\r\n  const m = /zone\\s*(\\d+)\\s*([NS])?/i.exec(String(cit));\r\n  if (m){ const zone=Number(m[1]); const south=(m[2]||'N').toUpperCase()==='S'; return `+proj=utm +zone=${zone}${south?' +south':''} +datum=WGS84 +units=m +no_defs`; }\r\n  // 不明なら経緯度とみなす（最小驚き：少なくとも表示はされる）\r\n  return 'EPSG:4326';\r\n}\r\n\r\nasync function bboxToLeafletBounds4326(bbox, srcProjDef){\r\n  // bbox: [minX,minY,maxX,maxY]（画像の座標系）\r\n  const proj4 = await getProj4();\r\n  const toWGS84 = (xy) => srcProjDef==='EPSG:4326' ? [xy[1], xy[0]] : proj4(srcProjDef, 'EPSG:4326', xy).slice().reverse();\r\n  const p1 = toWGS84([bbox[0], bbox[1]]); // SW?\r\n  const p2 = toWGS84([bbox[2], bbox[3]]); // NE?\r\n  // 投影→緯度経度へ変換後、Leaflet 用に [ [南,西], [北,東] ] を正規化\r\n  const south = Math.min(p1[0], p2[0]), north = Math.max(p1[0], p2[0]);\r\n  const west  = Math.min(p1[1], p2[1]), east  = Math.max(p1[1], p2[1]);\r\n  return [[south, west], [north, east]];\r\n}\r\n\r\n/**\r\n * GeoTIFFデータからキャンバスイメージを作成（RGBA化 & バウンディングボックス変換）\r\n * @param {Object} imageData - 画像データ\r\n * @param {Object} image - GeoTIFFイメージ\r\n * @param {number} width - 画像の幅\r\n * @param {number} height - 画像の高さ\r\n * @returns {Object} dataUrlとboundsLatLngを含むオブジェクト\r\n */\r\nasync function createRGBAImageFromGeoTIFF(imageData, image, width, height) {\r\n  // キャンバスを作成\r\n  const canvas = document.createElement('canvas');\r\n  canvas.width = width;\r\n  canvas.height = height;\r\n  const ctx = canvas.getContext('2d');\r\n  \r\n  // 画像データをキャンバスに描画（RGB または グレースケール）\r\n  if (imageData && imageData.length) {\r\n    // グレースケール（1バンド）の場合\r\n    if (imageData.length === 1) {\r\n      const band = imageData[0];\r\n      const out = ctx.createImageData(width, height);\r\n      \r\n      // NoData 値の取得と処理\r\n      const nodataRaw = image.getGDALNoData ? await image.getGDALNoData() : undefined;\r\n      const nodata = nodataRaw !== undefined && nodataRaw !== null && nodataRaw !== '' ? Number(nodataRaw) : undefined;\r\n      const norm = normalizeBand(band);\r\n      \r\n      for (let i=0;i<band.length;i++){\r\n        const v = band[i];\r\n        const p = i<<2;\r\n        if (nodata !== undefined && Number.isFinite(nodata) && v === nodata){\r\n          out.data[p+3] = 0;              // NoData は完全に透明\r\n          continue;\r\n        }\r\n        const g = norm(v)|0;\r\n        out.data[p] = out.data[p+1] = out.data[p+2] = g;\r\n        out.data[p+3] = 255;              // 可視化する画素は不透明\r\n      }\r\n      ctx.putImageData(out, 0, 0);\r\n    } else {\r\n      // RGB(A)（3〜4バンド）の場合\r\n      const R=imageData[0], G=imageData[1], B=imageData[2]; // 4番目はアルファ扱いしない（NIR等の可能性）\r\n      const nodataRaw = image.getGDALNoData ? await image.getGDALNoData() : undefined;\r\n      const nodata = nodataRaw !== undefined && nodataRaw !== null && nodataRaw !== '' ? Number(nodataRaw) : undefined;\r\n      const len = width * height;\r\n      const px  = new Uint8ClampedArray(len * 4); // 書き込み先は常に px\r\n      const hasND = Number.isFinite(nodata);\r\n\r\n      // 1バンドのときは 0-255 に正規化（可視化のため）\r\n      const band1 = bands.length === 1 ? bands[0] : null;\r\n      let norm = null;\r\n      if (band1) {\r\n        let min=Infinity,max=-Infinity;\r\n        for (let i=0;i<len;i++){ const v=band1[i]; if(Number.isFinite(v)){ if(v<min)min=v; if(v>max)max=v; } }\r\n        const span = (max>min)? (255/(max-min)) : 1;\r\n        norm = (v)=> Math.max(0, Math.min(255, Math.round((v-min)*span)));\r\n        console.info(`GeoTIFF 1バンドの可視化: min=${min}, max=${max}`);\r\n      }\r\n\r\n      for (let i=0;i<len;i++){\r\n        const p = i<<2;\r\n        // --- NoData 判定を「全バンド NoData の時だけ透明」に変更（全面透明化の防止）\r\n        if (hasND){\r\n          let allNoData = true;\r\n          for (let b=0;b<bands.length;b++){\r\n            if (bands[b][i] !== nodata){ allNoData = false; break; }\r\n          }\r\n          if (allNoData){ px[p+3]=0; continue; }\r\n        }\r\n        if (bands.length===1){\r\n          const g = norm ? norm(band1[i]) : (band1[i] & 0xff);\r\n          px[p]=g; px[p+1]=g; px[p+2]=g; px[p+3]=255;\r\n        }else{\r\n          px[p]    = bands[0][i] & 0xff;\r\n          px[p+1]  = bands[1][i] & 0xff;\r\n          px[p+2]  = bands[2][i] & 0xff;\r\n          px[p+3]  = 255;\r\n        }\r\n      }\r\n      \r\n      // Leaflet の ImageOverlay 用に BlobURL を作る\r\n      const canvas = document.createElement('canvas');\r\n      canvas.width = width; canvas.height = height;\r\n      const ctx = canvas.getContext('2d');\r\n      ctx.putImageData(new ImageData(px, width, height), 0, 0);\r\n      const blob = await new Promise(res=> canvas.toBlob(res));\r\n      const url = URL.createObjectURL(blob);\r\n      return { url, width, height, bounds };\r\n    }\r\n  } else {\r\n    // デフォルトの表示（テスト用）\r\n    ctx.fillStyle = '#8bc34a';\r\n    ctx.fillRect(0, 0, width, height);\r\n  }\r\n  \r\n  // そのままキャンバスへ出力 → Blob URL（巨大 dataURL を避ける）\r\n  // キャンバスへ配置（px を使う）\r\n  // Get the image data from the canvas context for both cases\r\n  const imageDataFromCanvas = ctx.getImageData(0, 0, width, height);\r\n  const raw = new ImageData(imageDataFromCanvas.data, width, height);\r\n  const tmp = document.createElement('canvas');\r\n  tmp.width = width; tmp.height = height;\r\n  const tctx = tmp.getContext('2d');\r\n  tctx.putImageData(raw, 0, 0);                       // 正: raw(px)\r\n  // ブラウザ/GPU の限界対策：最大辺 8192 に縮小（オリジナルが大きい場合）\r\n  const MAX_EDGE = 8192;\r\n  let finalCanvas = tmp;\r\n  if (Math.max(width, height) > MAX_EDGE) {\r\n    const scale = MAX_EDGE / Math.max(width, height);\r\n    const c2 = document.createElement('canvas');\r\n    c2.width = Math.round(width*scale);\r\n    c2.height = Math.round(height*scale);\r\n    c2.getContext('2d').drawImage(tmp, 0, 0, c2.width, c2.height);\r\n    finalCanvas = c2;\r\n  }\r\n  const blob = await new Promise(res=>finalCanvas.toBlob(res, 'image/png', 0.92));\r\n  const dataUrl = URL.createObjectURL(blob);\r\n  \r\n  // バウンディングボックスを緯度経度に変換\r\n  const boundsLatLng = computeLatLngBounds(image);\r\n  \r\n  return { dataUrl, boundsLatLng };\r\n}\r\n\r\n// WebMercator(EPSG:3857) → WGS84緯度経度\r\nconst R = 6378137;\r\nfunction mercToLonLat(x, y) {\r\n  const lon = (x / R) * 180 / Math.PI;\r\n  const lat = (2 * Math.atan(Math.exp(y / R)) - Math.PI / 2) * 180 / Math.PI;\r\n  const maxLat = 85.05112878; // WebMercator の理論上限\r\n  return [lon, Math.max(Math.min(lat, maxLat), -maxLat)];\r\n}\r\nfunction looksLike3857BBox([minX, minY, maxX, maxY]) {\r\n  // 4326(度)なら |x|≤180, |y|≤90 程度。超えていれば 3857(m) と推定\r\n  return Math.abs(minX) > 180 || Math.abs(maxX) > 180 || Math.abs(minY) > 90 || Math.abs(maxY) > 90;\r\n}\r\nfunction bboxToLatLngBounds(bbox, epsg) {\r\n  let sw, ne;\r\n  if (epsg === 3857 || (!epsg && looksLike3857BBox(bbox))) {\r\n    const [w, s] = mercToLonLat(bbox[0], bbox[1]);\r\n    const [e, n] = mercToLonLat(bbox[2], bbox[3]);\r\n    sw = [s, w]; ne = [n, e];\r\n  } else {\r\n    // 既に度（EPSG:4326 相当）\r\n    sw = [bbox[1], bbox[0]];\r\n    ne = [bbox[3], bbox[2]];\r\n  }\r\n  return L.latLngBounds(sw, ne);\r\n}\r\n\r\nfunction computeLatLngBounds(image) {\r\n  // まずは geotiff.js の getBoundingBox があれば使う\r\n  let west, south, east, north;\r\n  if (typeof image.getBoundingBox === 'function') {\r\n    const bb = image.getBoundingBox(); // [minX, minY, maxX, maxY]（多くは3857）\r\n    [west, south, east, north] = bb;\r\n  } else {\r\n    // TiePoint + PixelScale から算出（yは画像下向きなので minus）\r\n    const tie = image.getTiePoints()[0];\r\n    const scale = image.getFileDirectory().ModelPixelScale;\r\n    const w = image.getWidth(), h = image.getHeight();\r\n    west  = tie.x;\r\n    north = tie.y;\r\n    east  = west  + w * scale[0];\r\n    south = north - h * scale[1];\r\n  }\r\n  // SRS 判定（GeoKey で 3857 が来るケースを優先）\r\n  let boundsLatLng;\r\n  const gk = (typeof image.getGeoKeys==='function') ? image.getGeoKeys() : {};\r\n  const is3857 = gk.ProjectedCSTypeGeoKey===3857 || gk.ProjectedCSTypeGeoKey===900913;\r\n  if (is3857) {\r\n    const sw = mercToLonLat(west, south);\r\n    const ne = mercToLonLat(east, north);\r\n    boundsLatLng = [[sw[1], sw[0]],[ne[1], ne[0]]];\r\n  } else {\r\n    // 既に経緯度（EPSG:4326）想定\r\n    boundsLatLng = [[south, west],[north, east]];\r\n  }\r\n  \r\n  return boundsLatLng;\r\n}\r\n\r\n/**\r\n * GeoTIFFファイルを読み込む関数（段階ログ付き）\r\n * @param {File} file - 読み込むGeoTIFFファイル\r\n * @returns {Promise<Object>} GeoTIFFイメージデータ\r\n */\r\nexport async function loadGeoTIFFWithSteps(file) {\r\n  try {\r\n    return await step(`File selected: ${file.name} (${file.size} bytes)`, async () => {\r\n      const buf = await step('Read as ArrayBuffer', () => file.arrayBuffer());\r\n      const tiff = await step('geotiff.fromArrayBuffer', () => fromArrayBuffer(buf));\r\n      const image = await step('tiff.getImage(0)', () => tiff.getImage(0));\r\n      \r\n      const bbox = await step('image.getBoundingBox', () => image.getBoundingBox());\r\n      // GeoKey から EPSG を取得（無い場合は数値スケールから自動推定）\r\n      const geoKeys = (image.getGeoKeys && image.getGeoKeys()) || {};\r\n      const epsg =\r\n        geoKeys.ProjectedCSTypeGeoKey ||  // 例: 3857\r\n        geoKeys.GeographicTypeGeoKey ||   // 例: 4326\r\n        undefined;                        // 不明→推定\r\n\r\n      const width  = image.getWidth();\r\n      const height = image.getHeight();\r\n      const keys = image.getGeoKeys?.() || {};\r\n      const epsgCode = keys.ProjectedCSTypeGeoKey || keys.GeographicTypeGeoKey || 'unknown';\r\n      report({phase:'image-meta', width, height, bbox, epsg: epsgCode});\r\n\r\n      // 4326/3857 以外なら注意を出す（描画失敗の典型原因）\r\n      if (![4326, 3857].includes(Number(epsgCode))) {\r\n        report(raise(ERR.GEO_RENDER, '想定外の座標系の可能性', { epsg: epsgCode }), 'warn');\r\n      }\r\n\r\n      // 3857→4326 変換を挟んで Leaflet Bounds を作成\r\n      const bounds = bboxToLatLngBounds(bbox, epsg);\r\n      \r\n      // ここで地図へ反映（最低限の動作例：範囲へズーム）\r\n      // 実際のラスタ表示処理（既存の描画関数）も step() で包むと特定が速い\r\n      const { url } = await step('Render raster overlay', async () => {\r\n        // 既存の処理を使用\r\n        return await loadGeoTIFFFromFileData(buf);\r\n      });\r\n      \r\n      // URL と正しい bounds を返す（呼び出し側で地図へ追加）\r\n      return { url, bounds };\r\n    });\r\n  } catch (e) {\r\n    report(raise(ERR.GEO_PARSE, 'GeoTIFF 読み込みに失敗', { file: file.name }, e));\r\n    throw e;\r\n  }\r\n}\r\n\r\n/**\r\n * ファイルデータからGeoTIFFを読み込むヘルパー関数\r\n * @param {ArrayBuffer} buf - ファイルのArrayBuffer\r\n * @returns {Promise<Object>} GeoTIFFイメージデータ\r\n */\r\nasync function loadGeoTIFFFromFileData(buf) {\r\n  // 既存のloadGeoTIFF関数を再利用\r\n  return await loadGeoTIFF(buf);\r\n}"],"file":"assets/geotiff-loader-chAyHYja.js"}