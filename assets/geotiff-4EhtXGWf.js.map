{"version":3,"mappings":"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","names":["uncurryThis","target","thisArg","args","ReflectApply","uncurryThisGetter","key","ReflectGetOwnPropertyDescriptor","ReflectGetPrototypeOf","ReflectOwnKeys","SymbolIterator","SymbolToStringTag","NativeObject","ObjectCreate","ObjectDefineProperty","NativeArray","ArrayPrototype","NativeArrayPrototypeSymbolIterator","ArrayPrototypeSymbolIterator","NativeArrayBuffer","ArrayBufferPrototype","NativeSharedArrayBuffer","TypedArray","TypedArrayPrototype","NativeUint8Array","NativeUint16Array","NativeUint32Array","NativeFloat32Array","ArrayIteratorPrototype","ArrayIteratorPrototypeNext","GeneratorPrototypeNext","IteratorPrototype","DataViewPrototype","DataViewPrototypeGetUint16","NativeWeakMap","WeakMapPrototype","WeakMapPrototypeGet","WeakMapPrototypeSet","arrayIterators","SafeIteratorPrototype","arrayIterator","safeIfNeeded","array","safe","generators","DummyArrayIteratorPrototype","generator","buffer","floatView","uint32View","baseTable","shiftTable","i","mantissaTable","m","e","exponentTable","offsetTable","convertToNumber","float16bits","getFloat16","dataView","byteOffset","opts","getAttribute","tag","attributeName","options","debug","xml","opening","quotechars","char","pattern","match","getAttributeModule","indexOfMatch","startIndex","indexOfMatchModule","indexOfMatchEnd","indexOfMatchEndModule","countSubstring","string","substring","countSubstringModule","require$$0","require$$1","require$$2","findTagByName","tagName","nested","start","afterStart","relativeEnd","selfClosing","openings","closings","clip","end","outer","inner","findTagByNameModule","findTagsByName","tags","findTagsByNameModule","fieldTagNames","fieldTags","fieldTagTypes","arrayFields","fieldTypeNames","fieldTypes","photometricInterpretations","ExtraSamplesValues","LercParameters","LercAddCompression","geoKeyNames","geoKeys","fromWhiteIsZero","raster","max","width","height","rgbRaster","value","j","fromBlackIsZero","fromPalette","colorMap","greenOffset","blueOffset","mapIndex","fromCMYK","cmykRaster","c","y","k","fromYCbCr","yCbCrRaster","cb","cr","Xn","Yn","Zn","fromCIELab","cieLabRaster","L","a_","b_","x","z","r","g","b","registry","addDecoder","cases","importFn","getDecoder","fileDirectory","Decoder","__vitePreload","copyNewSize","samplesPerPixel","resampleNearest","valueArrays","inWidth","inHeight","outWidth","outHeight","relX","relY","newArray","cy","cx","lerp","v0","v1","resampleBilinear","rawY","yl","yh","rawX","tx","xl","xh","ll","hl","lh","hh","resample","method","resampleNearestInterleaved","valueArray","samples","resampleBilinearInterleaved","resampleInterleaved","sum","arrayForType","format","bitsPerSample","size","needsNormalization","normalizeArray","inBuffer","planarConfiguration","tileWidth","tileHeight","view","outSize","samplesToTransfer","outArray","bitMask","pixelBitSkip","bitsPerLine","lineBitOffset","pixelBitOffset","bitOffset","outIndex","innerBitOffset","raw","GeoTIFFImage","littleEndian","cache","source","bytes","sampleIndex","offset","sample","poolOrDecoder","signal","numTilesPerRow","numTilesPerCol","index","tiles","byteCount","slice","request","data","sampleFormat","imageWindow","interleave","resampleMethod","imageWidth","imageHeight","minXTile","maxXTile","minYTile","maxYTile","windowWidth","bytesPerPixel","srcSampleOffsets","sampleReaders","promises","yTile","xTile","getPromise","si","promise","tile","blockHeight","firstLine","firstCol","lastLine","lastCol","reader","ymax","xmax","pixelOffset","windowCoordinate","resampled","wnd","pool","fillValue","imageWindowWidth","imageWindowHeight","numPixels","window","enableAlpha","pi","s","subOptions","red","green","blue","tiePoints","metadata","items","item","modelTransformation","referenceImage","modelPixelScale","refResX","refResY","refResZ","tilegrid","a","d","f","projected","I","J","xs","pt","ys","origin","resolution","x1","y1","x2","y2","DataView64","arrayBuffer","left","right","combined","isNegative","carrying","byte","DataSlice","sliceOffset","bigTiff","length","defaultPoolSize","Pool","createWorker","resolve","module","create","decoder","worker","candidate","id","onMessage","CRLFCRLF","itemsToObject","obj","parseHeaders","text","line","kv","str","parseContentType","rawContentType","type","rawParams","paramsItems","param","parseContentRange","rawContentRange","total","parseByteRanges","responseArrayBuffer","boundary","out","startBoundary","endBoundary","innerText","endOfHeaders","headers","startOfData","BaseSource","slices","QuickLRU","maxAge","expiry","deleted","newSize","removeCount","oldCacheSize","callbackFunction","thisArgument","assign","endsWith","expectedEnding","forEach","iterable","func","invert","oldObj","newObj","times","numTimes","results","wait","milliseconds","zip","A","B","AbortError","params","CustomAggregateError","errors","message","AggregateError","Block","BlockGroup","blockIds","BlockedSource","blockSize","cacheSize","blockId","block","blockRequests","missingBlockIds","allBlockIds","top","fileSize","firstBlockOffset","current","missingRequests","abortedBlockRequests","abortedBlockIds","blocks","failedBlocks","requiredBlocks","groups","groupRequests","groupIndex","group","response","blockOffset","o","t","err","sortedBlockIds","lastBlockId","blockIdLow","blockIdHigh","sliceData","sliceView","delta","topDelta","blockInnerOffset","rangeInnerOffset","usedBlockLength","blockView","BaseResponse","headerName","BaseClient","url","FetchResponse","name","FetchClient","credentials","XHRResponse","xhr","XHRClient","reject","fs","HttpResponse","dataPromise","HttpClient","urlMod","http","resolveData","chunks","chunk","RemoteSource","client","maxRanges","allowFullFile","byteRanges","first","others","maybeWrapInBlockedSource","makeFetchSource","blockOptions","makeXHRSource","makeHttpSource","makeCustomSource","makeRemoteSource","forceXHR","clientOptions","ArrayBufferSource","makeBufferSource","FileReaderSource","file","blob","event","makeFileReaderSource","closeAsync","fd","openAsync","path","flags","mode","readAsync","bytesRead","FileSource","makeFileSource","tagName2Code","geoKeyName2Code","name2code","typeName2byte","numBytesInIfd","_binBE","oincr","buff","p","l","n","_writeIFD","bin","_offset","ifd","keys","eoff","typeName","typeNum","val","num","dlen","toff","encodeIfds","ifds","ifdo","noffs","result","encodeImage","values","prfx","img","convertToTids","input","toArray","metadataDefaults","writeGeotiff","isFlattened","numBands","flattenedValues","rowIndex","columnIndex","bandIndex","geoAsciiParams","code","GeoKeyDirectory","geoKey","KeyID","Count","TIFFTagLocation","valueOffset","encodedMetadata","DummyLogger","setLogger","logger","decodeRowAcc","row","stride","decodeRowFloatingPoint","bytesPerSample","count","wc","copy","applyPredictor","predictor","BaseDecoder","decoded","isTiled","getFieldTypeLength","fieldType","parseGeoKeyDirectory","rawGeoKeyDirectory","geoKeyDirectory","location","getValues","dataSlice","readMethod","fieldTypeLength","ImageFileDirectory","nextIFDByteOffset","GeoTIFFImageIndexError","GeoTIFFBase","resX","resY","bbox","firstImage","usedImage","imageCount","imgBBox","oX","oY","rX","rY","usedBBox","allImages","image","subfileType","newSubfileType","imgResX","imgResY","imageResX","imageResY","GeoTIFF","firstIFDOffset","fallbackSize","entrySize","offsetSize","numDirEntries","byteSize","entryCount","fieldTag","typeCount","fieldValues","actualOffset","fieldDataSlice","previousIfd","hasNext","detectionString","heuristicAreaSize","metadataSize","fullString","headerData","BOM","magicNumber","MultiGeoTIFF","mainFile","overviewFiles","requests","visited","relativeIndex","imageFile","ii","fromUrl","fromCustomClient","fromArrayBuffer","fromFile","fromBlob","fromUrls","mainUrl","overviewUrls","writeArrayBuffer"],"ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,27,28,29,30,31,32,33,34,35,36],"sources":["../../node_modules/@petamoriken/float16/src/_util/primordials.mjs","../../node_modules/@petamoriken/float16/src/_util/arrayIterator.mjs","../../node_modules/@petamoriken/float16/src/_util/converter.mjs","../../node_modules/@petamoriken/float16/src/DataView.mjs","../../node_modules/xml-utils/get-attribute.js","../../node_modules/xml-utils/index-of-match.js","../../node_modules/xml-utils/index-of-match-end.js","../../node_modules/xml-utils/count-substring.js","../../node_modules/xml-utils/find-tag-by-name.js","../../node_modules/xml-utils/find-tags-by-name.js","../../node_modules/geotiff/dist-module/globals.js","../../node_modules/geotiff/dist-module/rgb.js","../../node_modules/geotiff/dist-module/compression/index.js","../../node_modules/geotiff/dist-module/resample.js","../../node_modules/geotiff/dist-module/geotiffimage.js","../../node_modules/geotiff/dist-module/dataview64.js","../../node_modules/geotiff/dist-module/dataslice.js","../../node_modules/geotiff/dist-module/pool.js","../../node_modules/geotiff/dist-module/source/httputils.js","../../node_modules/geotiff/dist-module/source/basesource.js","../../node_modules/quick-lru/index.js","../../node_modules/geotiff/dist-module/utils.js","../../node_modules/geotiff/dist-module/source/blockedsource.js","../../node_modules/geotiff/dist-module/source/client/base.js","../../node_modules/geotiff/dist-module/source/client/fetch.js","../../node_modules/geotiff/dist-module/source/client/xhr.js","../../__vite-browser-external","../../node_modules/geotiff/dist-module/source/client/http.js","../../node_modules/geotiff/dist-module/source/remote.js","../../node_modules/geotiff/dist-module/source/arraybuffer.js","../../node_modules/geotiff/dist-module/source/filereader.js","../../node_modules/geotiff/dist-module/source/file.js","../../node_modules/geotiff/dist-module/geotiffwriter.js","../../node_modules/geotiff/dist-module/logging.js","../../node_modules/geotiff/dist-module/predictor.js","../../node_modules/geotiff/dist-module/compression/basedecoder.js","../../node_modules/geotiff/dist-module/geotiff.js"],"sourcesContent":["/* eslint-disable no-restricted-globals, no-restricted-syntax */\n/* global SharedArrayBuffer */\n\nimport { CANNOT_CONVERT_UNDEFINED_OR_NULL_TO_OBJECT } from \"./messages.mjs\";\n\n/** @type {<T extends (...args: any) => any>(target: T) => (thisArg: ThisType<T>, ...args: any[]) => any} */\nfunction uncurryThis(target) {\n  return (thisArg, ...args) => {\n    return ReflectApply(target, thisArg, args);\n  };\n}\n\n/** @type {(target: any, key: string | symbol) => (thisArg: any, ...args: any[]) => any} */\nfunction uncurryThisGetter(target, key) {\n  return uncurryThis(\n    ReflectGetOwnPropertyDescriptor(\n      target,\n      key\n    ).get\n  );\n}\n\n// Reflect\nexport const {\n  apply: ReflectApply,\n  construct: ReflectConstruct,\n  defineProperty: ReflectDefineProperty,\n  get: ReflectGet,\n  getOwnPropertyDescriptor: ReflectGetOwnPropertyDescriptor,\n  getPrototypeOf: ReflectGetPrototypeOf,\n  has: ReflectHas,\n  ownKeys: ReflectOwnKeys,\n  set: ReflectSet,\n  setPrototypeOf: ReflectSetPrototypeOf,\n} = Reflect;\n\n// Proxy\nexport const NativeProxy = Proxy;\n\n// Number\nexport const {\n  EPSILON,\n  MAX_SAFE_INTEGER,\n  isFinite: NumberIsFinite,\n  isNaN: NumberIsNaN,\n} = Number;\n\n// Symbol\nexport const {\n  iterator: SymbolIterator,\n  species: SymbolSpecies,\n  toStringTag: SymbolToStringTag,\n  for: SymbolFor,\n} = Symbol;\n\n// Object\nexport const NativeObject = Object;\nexport const {\n  create: ObjectCreate,\n  defineProperty: ObjectDefineProperty,\n  freeze: ObjectFreeze,\n  is: ObjectIs,\n} = NativeObject;\nconst ObjectPrototype = NativeObject.prototype;\n/** @type {(object: object, key: PropertyKey) => Function | undefined} */\nexport const ObjectPrototype__lookupGetter__ = /** @type {any} */ (ObjectPrototype).__lookupGetter__\n  ? uncurryThis(/** @type {any} */ (ObjectPrototype).__lookupGetter__)\n  : (object, key) => {\n    if (object == null) {\n      throw NativeTypeError(\n        CANNOT_CONVERT_UNDEFINED_OR_NULL_TO_OBJECT\n      );\n    }\n\n    let target = NativeObject(object);\n    do {\n      const descriptor = ReflectGetOwnPropertyDescriptor(target, key);\n      if (descriptor !== undefined) {\n        if (ObjectHasOwn(descriptor, \"get\")) {\n          return descriptor.get;\n        }\n\n        return;\n      }\n    } while ((target = ReflectGetPrototypeOf(target)) !== null);\n  };\n/** @type {(object: object, key: PropertyKey) => boolean} */\nexport const ObjectHasOwn = /** @type {any} */ (NativeObject).hasOwn ||\n  uncurryThis(ObjectPrototype.hasOwnProperty);\n\n// Array\nconst NativeArray = Array;\nexport const ArrayIsArray = NativeArray.isArray;\nconst ArrayPrototype = NativeArray.prototype;\n/** @type {(array: ArrayLike<unknown>, separator?: string) => string} */\nexport const ArrayPrototypeJoin = uncurryThis(ArrayPrototype.join);\n/** @type {<T>(array: T[], ...items: T[]) => number} */\nexport const ArrayPrototypePush = uncurryThis(ArrayPrototype.push);\n/** @type {(array: ArrayLike<unknown>, ...opts: any[]) => string} */\nexport const ArrayPrototypeToLocaleString = uncurryThis(\n  ArrayPrototype.toLocaleString\n);\nexport const NativeArrayPrototypeSymbolIterator = ArrayPrototype[SymbolIterator];\n/** @type {<T>(array: T[]) => IterableIterator<T>} */\nexport const ArrayPrototypeSymbolIterator = uncurryThis(NativeArrayPrototypeSymbolIterator);\n\n// Math\nexport const {\n  abs: MathAbs,\n  trunc: MathTrunc,\n} = Math;\n\n// ArrayBuffer\nexport const NativeArrayBuffer = ArrayBuffer;\nexport const ArrayBufferIsView = NativeArrayBuffer.isView;\nconst ArrayBufferPrototype = NativeArrayBuffer.prototype;\n/** @type {(buffer: ArrayBuffer, begin?: number, end?: number) => number} */\nexport const ArrayBufferPrototypeSlice = uncurryThis(ArrayBufferPrototype.slice);\n/** @type {(buffer: ArrayBuffer) => ArrayBuffer} */\nexport const ArrayBufferPrototypeGetByteLength = uncurryThisGetter(ArrayBufferPrototype, \"byteLength\");\n\n// SharedArrayBuffer\nexport const NativeSharedArrayBuffer = typeof SharedArrayBuffer !== \"undefined\" ? SharedArrayBuffer : null;\n/** @type {(buffer: SharedArrayBuffer) => SharedArrayBuffer} */\nexport const SharedArrayBufferPrototypeGetByteLength = NativeSharedArrayBuffer\n  && uncurryThisGetter(NativeSharedArrayBuffer.prototype, \"byteLength\");\n\n// TypedArray\n/** @typedef {Uint8Array|Uint8ClampedArray|Uint16Array|Uint32Array|Int8Array|Int16Array|Int32Array|Float32Array|Float64Array|BigUint64Array|BigInt64Array} TypedArray */\n/** @type {any} */\nexport const TypedArray = ReflectGetPrototypeOf(Uint8Array);\nconst TypedArrayFrom = TypedArray.from;\nexport const TypedArrayPrototype = TypedArray.prototype;\nexport const NativeTypedArrayPrototypeSymbolIterator = TypedArrayPrototype[SymbolIterator];\n/** @type {(typedArray: TypedArray) => IterableIterator<number>} */\nexport const TypedArrayPrototypeKeys = uncurryThis(TypedArrayPrototype.keys);\n/** @type {(typedArray: TypedArray) => IterableIterator<number>} */\nexport const TypedArrayPrototypeValues = uncurryThis(\n  TypedArrayPrototype.values\n);\n/** @type {(typedArray: TypedArray) => IterableIterator<[number, number]>} */\nexport const TypedArrayPrototypeEntries = uncurryThis(\n  TypedArrayPrototype.entries\n);\n/** @type {(typedArray: TypedArray, array: ArrayLike<number>, offset?: number) => void} */\nexport const TypedArrayPrototypeSet = uncurryThis(TypedArrayPrototype.set);\n/** @type {<T extends TypedArray>(typedArray: T) => T} */\nexport const TypedArrayPrototypeReverse = uncurryThis(\n  TypedArrayPrototype.reverse\n);\n/** @type {<T extends TypedArray>(typedArray: T, value: number, start?: number, end?: number) => T} */\nexport const TypedArrayPrototypeFill = uncurryThis(TypedArrayPrototype.fill);\n/** @type {<T extends TypedArray>(typedArray: T, target: number, start: number, end?: number) => T} */\nexport const TypedArrayPrototypeCopyWithin = uncurryThis(\n  TypedArrayPrototype.copyWithin\n);\n/** @type {<T extends TypedArray>(typedArray: T, compareFn?: (a: number, b: number) => number) => T} */\nexport const TypedArrayPrototypeSort = uncurryThis(TypedArrayPrototype.sort);\n/** @type {<T extends TypedArray>(typedArray: T, start?: number, end?: number) => T} */\nexport const TypedArrayPrototypeSlice = uncurryThis(TypedArrayPrototype.slice);\n/** @type {<T extends TypedArray>(typedArray: T, start?: number, end?: number) => T} */\nexport const TypedArrayPrototypeSubarray = uncurryThis(\n  TypedArrayPrototype.subarray\n);\n/** @type {((typedArray: TypedArray) => ArrayBuffer)} */\nexport const TypedArrayPrototypeGetBuffer = uncurryThisGetter(\n  TypedArrayPrototype,\n  \"buffer\"\n);\n/** @type {((typedArray: TypedArray) => number)} */\nexport const TypedArrayPrototypeGetByteOffset = uncurryThisGetter(\n  TypedArrayPrototype,\n  \"byteOffset\"\n);\n/** @type {((typedArray: TypedArray) => number)} */\nexport const TypedArrayPrototypeGetLength = uncurryThisGetter(\n  TypedArrayPrototype,\n  \"length\"\n);\n/** @type {(target: unknown) => string} */\nexport const TypedArrayPrototypeGetSymbolToStringTag = uncurryThisGetter(\n  TypedArrayPrototype,\n  SymbolToStringTag\n);\n\n// Uint8Array\nexport const NativeUint8Array = Uint8Array;\n\n// Uint16Array\nexport const NativeUint16Array = Uint16Array;\n/** @type {Uint16ArrayConstructor[\"from\"]} */\nexport const Uint16ArrayFrom = (...args) => {\n  return ReflectApply(TypedArrayFrom, NativeUint16Array, args);\n};\n\n// Uint32Array\nexport const NativeUint32Array = Uint32Array;\n\n// Float32Array\nexport const NativeFloat32Array = Float32Array;\n\n// ArrayIterator\n/** @type {any} */\nexport const ArrayIteratorPrototype = ReflectGetPrototypeOf([][SymbolIterator]());\n/** @type {<T>(arrayIterator: IterableIterator<T>) => IteratorResult<T>} */\nexport const ArrayIteratorPrototypeNext = uncurryThis(ArrayIteratorPrototype.next);\n\n// Generator\n/** @type {<T = unknown, TReturn = any, TNext = unknown>(generator: Generator<T, TReturn, TNext>, value?: TNext) => T} */\nexport const GeneratorPrototypeNext = uncurryThis((function* () {})().next);\n\n// Iterator\nexport const IteratorPrototype = ReflectGetPrototypeOf(ArrayIteratorPrototype);\n\n// DataView\nconst DataViewPrototype = DataView.prototype;\n/** @type {(dataView: DataView, byteOffset: number, littleEndian?: boolean) => number} */\nexport const DataViewPrototypeGetUint16 = uncurryThis(\n  DataViewPrototype.getUint16\n);\n/** @type {(dataView: DataView, byteOffset: number, value: number, littleEndian?: boolean) => void} */\nexport const DataViewPrototypeSetUint16 = uncurryThis(\n  DataViewPrototype.setUint16\n);\n\n// Error\nexport const NativeTypeError = TypeError;\nexport const NativeRangeError = RangeError;\n\n// WeakSet\n/**\n * Do not construct with arguments to avoid calling the \"add\" method\n * @type {{new <T extends {}>(): WeakSet<T>}}\n */\nexport const NativeWeakSet = WeakSet;\nconst WeakSetPrototype = NativeWeakSet.prototype;\n/** @type {<T extends {}>(set: WeakSet<T>, value: T) => Set<T>} */\nexport const WeakSetPrototypeAdd = uncurryThis(WeakSetPrototype.add);\n/** @type {<T extends {}>(set: WeakSet<T>, value: T) => boolean} */\nexport const WeakSetPrototypeHas = uncurryThis(WeakSetPrototype.has);\n\n// WeakMap\n/**\n * Do not construct with arguments to avoid calling the \"set\" method\n * @type {{new <K extends {}, V>(): WeakMap<K, V>}}\n */\nexport const NativeWeakMap = WeakMap;\nconst WeakMapPrototype = NativeWeakMap.prototype;\n/** @type {<K extends {}, V>(weakMap: WeakMap<K, V>, key: K) => V} */\nexport const WeakMapPrototypeGet = uncurryThis(WeakMapPrototype.get);\n/** @type {<K extends {}, V>(weakMap: WeakMap<K, V>, key: K) => boolean} */\nexport const WeakMapPrototypeHas = uncurryThis(WeakMapPrototype.has);\n/** @type {<K extends {}, V>(weakMap: WeakMap<K, V>, key: K, value: V) => WeakMap} */\nexport const WeakMapPrototypeSet = uncurryThis(WeakMapPrototype.set);\n","import {\n  ArrayIteratorPrototype,\n  ArrayIteratorPrototypeNext,\n  ArrayPrototypeSymbolIterator,\n  GeneratorPrototypeNext,\n  IteratorPrototype,\n  NativeArrayPrototypeSymbolIterator,\n  NativeWeakMap,\n  ObjectCreate,\n  ObjectDefineProperty,\n  ReflectGetOwnPropertyDescriptor,\n  ReflectOwnKeys,\n  SymbolIterator,\n  WeakMapPrototypeGet,\n  WeakMapPrototypeSet,\n} from \"./primordials.mjs\";\n\n/** @type {WeakMap<{}, IterableIterator<any>>} */\nconst arrayIterators = new NativeWeakMap();\n\nconst SafeIteratorPrototype = ObjectCreate(null, {\n  next: {\n    value: function next() {\n      const arrayIterator = WeakMapPrototypeGet(arrayIterators, this);\n      return ArrayIteratorPrototypeNext(arrayIterator);\n    },\n  },\n\n  [SymbolIterator]: {\n    value: function values() {\n      return this;\n    },\n  },\n});\n\n/**\n * Wrap the Array around the SafeIterator If Array.prototype [@@iterator] has been modified\n * @type {<T>(array: T[]) => Iterable<T>}\n */\nexport function safeIfNeeded(array) {\n  if (\n    array[SymbolIterator] === NativeArrayPrototypeSymbolIterator &&\n    ArrayIteratorPrototype.next === ArrayIteratorPrototypeNext\n  ) {\n    return array;\n  }\n\n  const safe = ObjectCreate(SafeIteratorPrototype);\n  WeakMapPrototypeSet(arrayIterators, safe, ArrayPrototypeSymbolIterator(array));\n  return safe;\n}\n\n/** @type {WeakMap<{}, Generator<any>>} */\nconst generators = new NativeWeakMap();\n\n/** @see https://tc39.es/ecma262/#sec-%arrayiteratorprototype%-object */\nconst DummyArrayIteratorPrototype = ObjectCreate(IteratorPrototype, {\n  next: {\n    value: function next() {\n      const generator = WeakMapPrototypeGet(generators, this);\n      return GeneratorPrototypeNext(generator);\n    },\n    writable: true,\n    configurable: true,\n  },\n});\n\nfor (const key of ReflectOwnKeys(ArrayIteratorPrototype)) {\n  // next method has already defined\n  if (key === \"next\") {\n    continue;\n  }\n\n  // Copy ArrayIteratorPrototype descriptors to DummyArrayIteratorPrototype\n  ObjectDefineProperty(DummyArrayIteratorPrototype, key, ReflectGetOwnPropertyDescriptor(ArrayIteratorPrototype, key));\n}\n\n/**\n * Wrap the Generator around the dummy ArrayIterator\n * @type {<T>(generator: Generator<T>) => IterableIterator<T>}\n */\nexport function wrap(generator) {\n  const dummy = ObjectCreate(DummyArrayIteratorPrototype);\n  WeakMapPrototypeSet(generators, dummy, generator);\n  return dummy;\n}\n","import {\n  EPSILON,\n  MathAbs,\n  NativeArrayBuffer,\n  NativeFloat32Array,\n  NativeUint16Array,\n  NativeUint32Array,\n  NativeUint8Array,\n  NumberIsFinite,\n  NumberIsNaN,\n} from \"./primordials.mjs\";\n\nconst INVERSE_OF_EPSILON = 1 / EPSILON;\n\n/**\n * rounds to the nearest value;\n * if the number falls midway, it is rounded to the nearest value with an even least significant digit\n * @param {number} num\n * @returns {number}\n */\nfunction roundTiesToEven(num) {\n  return (num + INVERSE_OF_EPSILON) - INVERSE_OF_EPSILON;\n}\n\nconst FLOAT16_MIN_VALUE = 6.103515625e-05;\nconst FLOAT16_MAX_VALUE = 65504;\nconst FLOAT16_EPSILON = 0.0009765625;\n\nconst FLOAT16_EPSILON_MULTIPLIED_BY_FLOAT16_MIN_VALUE = FLOAT16_EPSILON * FLOAT16_MIN_VALUE;\nconst FLOAT16_EPSILON_DEVIDED_BY_EPSILON = FLOAT16_EPSILON * INVERSE_OF_EPSILON;\n\n/**\n * round a number to a half float number\n * @param {unknown} num - double float\n * @returns {number} half float number\n */\nexport function roundToFloat16(num) {\n  const number = +num;\n\n  // NaN, Infinity, -Infinity, 0, -0\n  if (!NumberIsFinite(number) || number === 0) {\n    return number;\n  }\n\n  // finite except 0, -0\n  const sign = number > 0 ? 1 : -1;\n  const absolute = MathAbs(number);\n\n  // small number\n  if (absolute < FLOAT16_MIN_VALUE) {\n    return sign * roundTiesToEven(absolute / FLOAT16_EPSILON_MULTIPLIED_BY_FLOAT16_MIN_VALUE) * FLOAT16_EPSILON_MULTIPLIED_BY_FLOAT16_MIN_VALUE;\n  }\n\n  const temp = (1 + FLOAT16_EPSILON_DEVIDED_BY_EPSILON) * absolute;\n  const result = temp - (temp - absolute);\n\n  // large number\n  if (result > FLOAT16_MAX_VALUE || NumberIsNaN(result)) {\n    return sign * Infinity;\n  }\n\n  return sign * result;\n}\n\n// base algorithm: http://fox-toolkit.org/ftp/fasthalffloatconversion.pdf\n\nconst buffer = new NativeArrayBuffer(4);\nconst floatView = new NativeFloat32Array(buffer);\nconst uint32View = new NativeUint32Array(buffer);\n\nconst baseTable = new NativeUint16Array(512);\nconst shiftTable = new NativeUint8Array(512);\n\nfor (let i = 0; i < 256; ++i) {\n  const e = i - 127;\n\n  // very small number (0, -0)\n  if (e < -24) {\n    baseTable[i]         = 0x0000;\n    baseTable[i | 0x100] = 0x8000;\n    shiftTable[i]         = 24;\n    shiftTable[i | 0x100] = 24;\n\n  // small number (denorm)\n  } else if (e < -14) {\n    baseTable[i]         =  0x0400 >> (-e - 14);\n    baseTable[i | 0x100] = (0x0400 >> (-e - 14)) | 0x8000;\n    shiftTable[i]         = -e - 1;\n    shiftTable[i | 0x100] = -e - 1;\n\n  // normal number\n  } else if (e <= 15) {\n    baseTable[i]         =  (e + 15) << 10;\n    baseTable[i | 0x100] = ((e + 15) << 10) | 0x8000;\n    shiftTable[i]         = 13;\n    shiftTable[i | 0x100] = 13;\n\n  // large number (Infinity, -Infinity)\n  } else if (e < 128) {\n    baseTable[i]         = 0x7c00;\n    baseTable[i | 0x100] = 0xfc00;\n    shiftTable[i]         = 24;\n    shiftTable[i | 0x100] = 24;\n\n  // stay (NaN, Infinity, -Infinity)\n  } else {\n    baseTable[i]         = 0x7c00;\n    baseTable[i | 0x100] = 0xfc00;\n    shiftTable[i]         = 13;\n    shiftTable[i | 0x100] = 13;\n  }\n}\n\n/**\n * round a number to a half float number bits\n * @param {unknown} num - double float\n * @returns {number} half float number bits\n */\nexport function roundToFloat16Bits(num) {\n  floatView[0] = roundToFloat16(num);\n  const f = uint32View[0];\n  const e = (f >> 23) & 0x1ff;\n  return baseTable[e] + ((f & 0x007fffff) >> shiftTable[e]);\n}\n\nconst mantissaTable = new NativeUint32Array(2048);\nfor (let i = 1; i < 1024; ++i) {\n  let m = i << 13; // zero pad mantissa bits\n  let e = 0; // zero exponent\n\n  // normalized\n  while ((m & 0x00800000) === 0) {\n    m <<= 1;\n    e -= 0x00800000; // decrement exponent\n  }\n\n  m &= ~0x00800000; // clear leading 1 bit\n  e += 0x38800000; // adjust bias\n\n  mantissaTable[i] = m | e;\n}\nfor (let i = 1024; i < 2048; ++i) {\n  mantissaTable[i] = 0x38000000 + ((i - 1024) << 13);\n}\n\nconst exponentTable = new NativeUint32Array(64);\nfor (let i = 1; i < 31; ++i) {\n  exponentTable[i] = i << 23;\n}\nexponentTable[31] = 0x47800000;\nexponentTable[32] = 0x80000000;\nfor (let i = 33; i < 63; ++i) {\n  exponentTable[i] = 0x80000000 + ((i - 32) << 23);\n}\nexponentTable[63] = 0xc7800000;\n\nconst offsetTable = new NativeUint16Array(64);\nfor (let i = 1; i < 64; ++i) {\n  if (i !== 32) {\n    offsetTable[i] = 1024;\n  }\n}\n\n/**\n * convert a half float number bits to a number\n * @param {number} float16bits - half float number bits\n * @returns {number} double float\n */\nexport function convertToNumber(float16bits) {\n  const i = float16bits >> 10;\n  uint32View[0] = mantissaTable[offsetTable[i] + (float16bits & 0x3ff)] + exponentTable[i];\n  return floatView[0];\n}\n","import { safeIfNeeded } from \"./_util/arrayIterator.mjs\";\nimport { convertToNumber, roundToFloat16Bits } from \"./_util/converter.mjs\";\nimport {\n  DataViewPrototypeGetUint16,\n  DataViewPrototypeSetUint16,\n} from \"./_util/primordials.mjs\";\n\n/**\n * returns an unsigned 16-bit float at the specified byte offset from the start of the DataView\n * @param {DataView} dataView\n * @param {number} byteOffset\n * @param {[boolean]} opts\n * @returns {number}\n */\nexport function getFloat16(dataView, byteOffset, ...opts) {\n  return convertToNumber(\n    DataViewPrototypeGetUint16(dataView, byteOffset, ...safeIfNeeded(opts))\n  );\n}\n\n/**\n * stores an unsigned 16-bit float value at the specified byte offset from the start of the DataView\n * @param {DataView} dataView\n * @param {number} byteOffset\n * @param {number} value\n * @param {[boolean]} opts\n */\nexport function setFloat16(dataView, byteOffset, value, ...opts) {\n  return DataViewPrototypeSetUint16(\n    dataView,\n    byteOffset,\n    roundToFloat16Bits(value),\n    ...safeIfNeeded(opts)\n  );\n}\n","function getAttribute(tag, attributeName, options) {\n  const debug = (options && options.debug) || false;\n  if (debug) console.log(\"[xml-utils] getting \" + attributeName + \" in \" + tag);\n\n  const xml = typeof tag === \"object\" ? tag.outer : tag;\n\n  // only search for attributes in the opening tag\n  const opening = xml.slice(0, xml.indexOf(\">\") + 1);\n\n  const quotechars = ['\"', \"'\"];\n  for (let i = 0; i < quotechars.length; i++) {\n    const char = quotechars[i];\n    const pattern = attributeName + \"\\\\=\" + char + \"([^\" + char + \"]*)\" + char;\n    if (debug) console.log(\"[xml-utils] pattern:\", pattern);\n\n    const re = new RegExp(pattern);\n    const match = re.exec(opening);\n    if (debug) console.log(\"[xml-utils] match:\", match);\n    if (match) return match[1];\n  }\n}\n\nmodule.exports = getAttribute;\nmodule.exports.default = getAttribute;\n","function indexOfMatch(xml, pattern, startIndex) {\n  const re = new RegExp(pattern);\n  const match = re.exec(xml.slice(startIndex));\n  if (match) return startIndex + match.index;\n  else return -1;\n}\n\nmodule.exports = indexOfMatch;\nmodule.exports.default = indexOfMatch;\n","function indexOfMatchEnd(xml, pattern, startIndex) {\n  const re = new RegExp(pattern);\n  const match = re.exec(xml.slice(startIndex));\n  if (match) return startIndex + match.index + match[0].length - 1;\n  else return -1;\n}\n\nmodule.exports = indexOfMatchEnd;\nmodule.exports.default = indexOfMatchEnd;\n","function countSubstring(string, substring) {\n  const pattern = new RegExp(substring, \"g\");\n  const match = string.match(pattern);\n  return match ? match.length : 0;\n}\n\nmodule.exports = countSubstring;\nmodule.exports.default = countSubstring;\n","const indexOfMatch = require(\"./index-of-match.js\");\nconst indexOfMatchEnd = require(\"./index-of-match-end.js\");\nconst countSubstring = require(\"./count-substring.js\");\n\nfunction findTagByName(xml, tagName, options) {\n  const debug = (options && options.debug) || false;\n  const nested = !(options && typeof options.nested === false);\n\n  const startIndex = (options && options.startIndex) || 0;\n\n  if (debug) console.log(\"[xml-utils] starting findTagByName with\", tagName, \" and \", options);\n\n  const start = indexOfMatch(xml, `\\<${tagName}[ \\n\\>\\/]`, startIndex);\n  if (debug) console.log(\"[xml-utils] start:\", start);\n  if (start === -1) return undefined;\n\n  const afterStart = xml.slice(start + tagName.length);\n\n  let relativeEnd = indexOfMatchEnd(afterStart, \"^[^<]*[ /]>\", 0);\n\n  const selfClosing = relativeEnd !== -1 && afterStart[relativeEnd - 1] === \"/\";\n  if (debug) console.log(\"[xml-utils] selfClosing:\", selfClosing);\n\n  if (selfClosing === false) {\n    // check if tag has subtags with the same name\n    if (nested) {\n      let startIndex = 0;\n      let openings = 1;\n      let closings = 0;\n      while ((relativeEnd = indexOfMatchEnd(afterStart, \"[ /]\" + tagName + \">\", startIndex)) !== -1) {\n        const clip = afterStart.substring(startIndex, relativeEnd + 1);\n        openings += countSubstring(clip, \"<\" + tagName + \"[ \\n\\t>]\");\n        closings += countSubstring(clip, \"</\" + tagName + \">\");\n        // we can't have more openings than closings\n        if (closings >= openings) break;\n        startIndex = relativeEnd;\n      }\n    } else {\n      relativeEnd = indexOfMatchEnd(afterStart, \"[ /]\" + tagName + \">\", 0);\n    }\n  }\n\n  const end = start + tagName.length + relativeEnd + 1;\n  if (debug) console.log(\"[xml-utils] end:\", end);\n  if (end === -1) return undefined;\n\n  const outer = xml.slice(start, end);\n  // tag is like <gml:identifier codeSpace=\"OGP\">urn:ogc:def:crs:EPSG::32617</gml:identifier>\n\n  let inner;\n  if (selfClosing) {\n    inner = null;\n  } else {\n    inner = outer.slice(outer.indexOf(\">\") + 1, outer.lastIndexOf(\"<\"));\n  }\n\n  return { inner, outer, start, end };\n}\n\nmodule.exports = findTagByName;\nmodule.exports.default = findTagByName;\n","const findTagByName = require(\"./find-tag-by-name.js\");\n\nfunction findTagsByName(xml, tagName, options) {\n  const tags = [];\n  const debug = (options && options.debug) || false;\n  const nested = options && typeof options.nested === \"boolean\" ? options.nested : true;\n  let startIndex = (options && options.startIndex) || 0;\n  let tag;\n  while ((tag = findTagByName(xml, tagName, { debug, startIndex }))) {\n    if (nested) {\n      startIndex = tag.start + 1 + tagName.length;\n    } else {\n      startIndex = tag.end;\n    }\n    tags.push(tag);\n  }\n  if (debug) console.log(\"findTagsByName found\", tags.length, \"tags\");\n  return tags;\n}\n\nmodule.exports = findTagsByName;\nmodule.exports.default = findTagsByName;\n","export const fieldTagNames = {\n  // TIFF Baseline\n  0x013B: 'Artist',\n  0x0102: 'BitsPerSample',\n  0x0109: 'CellLength',\n  0x0108: 'CellWidth',\n  0x0140: 'ColorMap',\n  0x0103: 'Compression',\n  0x8298: 'Copyright',\n  0x0132: 'DateTime',\n  0x0152: 'ExtraSamples',\n  0x010A: 'FillOrder',\n  0x0121: 'FreeByteCounts',\n  0x0120: 'FreeOffsets',\n  0x0123: 'GrayResponseCurve',\n  0x0122: 'GrayResponseUnit',\n  0x013C: 'HostComputer',\n  0x010E: 'ImageDescription',\n  0x0101: 'ImageLength',\n  0x0100: 'ImageWidth',\n  0x010F: 'Make',\n  0x0119: 'MaxSampleValue',\n  0x0118: 'MinSampleValue',\n  0x0110: 'Model',\n  0x00FE: 'NewSubfileType',\n  0x0112: 'Orientation',\n  0x0106: 'PhotometricInterpretation',\n  0x011C: 'PlanarConfiguration',\n  0x0128: 'ResolutionUnit',\n  0x0116: 'RowsPerStrip',\n  0x0115: 'SamplesPerPixel',\n  0x0131: 'Software',\n  0x0117: 'StripByteCounts',\n  0x0111: 'StripOffsets',\n  0x00FF: 'SubfileType',\n  0x0107: 'Threshholding',\n  0x011A: 'XResolution',\n  0x011B: 'YResolution',\n\n  // TIFF Extended\n  0x0146: 'BadFaxLines',\n  0x0147: 'CleanFaxData',\n  0x0157: 'ClipPath',\n  0x0148: 'ConsecutiveBadFaxLines',\n  0x01B1: 'Decode',\n  0x01B2: 'DefaultImageColor',\n  0x010D: 'DocumentName',\n  0x0150: 'DotRange',\n  0x0141: 'HalftoneHints',\n  0x015A: 'Indexed',\n  0x015B: 'JPEGTables',\n  0x011D: 'PageName',\n  0x0129: 'PageNumber',\n  0x013D: 'Predictor',\n  0x013F: 'PrimaryChromaticities',\n  0x0214: 'ReferenceBlackWhite',\n  0x0153: 'SampleFormat',\n  0x0154: 'SMinSampleValue',\n  0x0155: 'SMaxSampleValue',\n  0x022F: 'StripRowCounts',\n  0x014A: 'SubIFDs',\n  0x0124: 'T4Options',\n  0x0125: 'T6Options',\n  0x0145: 'TileByteCounts',\n  0x0143: 'TileLength',\n  0x0144: 'TileOffsets',\n  0x0142: 'TileWidth',\n  0x012D: 'TransferFunction',\n  0x013E: 'WhitePoint',\n  0x0158: 'XClipPathUnits',\n  0x011E: 'XPosition',\n  0x0211: 'YCbCrCoefficients',\n  0x0213: 'YCbCrPositioning',\n  0x0212: 'YCbCrSubSampling',\n  0x0159: 'YClipPathUnits',\n  0x011F: 'YPosition',\n\n  // EXIF\n  0x9202: 'ApertureValue',\n  0xA001: 'ColorSpace',\n  0x9004: 'DateTimeDigitized',\n  0x9003: 'DateTimeOriginal',\n  0x8769: 'Exif IFD',\n  0x9000: 'ExifVersion',\n  0x829A: 'ExposureTime',\n  0xA300: 'FileSource',\n  0x9209: 'Flash',\n  0xA000: 'FlashpixVersion',\n  0x829D: 'FNumber',\n  0xA420: 'ImageUniqueID',\n  0x9208: 'LightSource',\n  0x927C: 'MakerNote',\n  0x9201: 'ShutterSpeedValue',\n  0x9286: 'UserComment',\n\n  // IPTC\n  0x83BB: 'IPTC',\n\n  // ICC\n  0x8773: 'ICC Profile',\n\n  // XMP\n  0x02BC: 'XMP',\n\n  // GDAL\n  0xA480: 'GDAL_METADATA',\n  0xA481: 'GDAL_NODATA',\n\n  // Photoshop\n  0x8649: 'Photoshop',\n\n  // GeoTiff\n  0x830E: 'ModelPixelScale',\n  0x8482: 'ModelTiepoint',\n  0x85D8: 'ModelTransformation',\n  0x87AF: 'GeoKeyDirectory',\n  0x87B0: 'GeoDoubleParams',\n  0x87B1: 'GeoAsciiParams',\n\n  // LERC\n  0xC5F2: 'LercParameters',\n};\n\nexport const fieldTags = {};\nfor (const key in fieldTagNames) {\n  if (fieldTagNames.hasOwnProperty(key)) {\n    fieldTags[fieldTagNames[key]] = parseInt(key, 10);\n  }\n}\n\nexport const fieldTagTypes = {\n  256: 'SHORT',\n  257: 'SHORT',\n  258: 'SHORT',\n  259: 'SHORT',\n  262: 'SHORT',\n  273: 'LONG',\n  274: 'SHORT',\n  277: 'SHORT',\n  278: 'LONG',\n  279: 'LONG',\n  282: 'RATIONAL',\n  283: 'RATIONAL',\n  284: 'SHORT',\n  286: 'SHORT',\n  287: 'RATIONAL',\n  296: 'SHORT',\n  297: 'SHORT',\n  305: 'ASCII',\n  306: 'ASCII',\n  338: 'SHORT',\n  339: 'SHORT',\n  513: 'LONG',\n  514: 'LONG',\n  1024: 'SHORT',\n  1025: 'SHORT',\n  2048: 'SHORT',\n  2049: 'ASCII',\n  3072: 'SHORT',\n  3073: 'ASCII',\n  33550: 'DOUBLE',\n  33922: 'DOUBLE',\n  34264: 'DOUBLE',\n  34665: 'LONG',\n  34735: 'SHORT',\n  34736: 'DOUBLE',\n  34737: 'ASCII',\n  42113: 'ASCII',\n};\n\nexport const arrayFields = [\n  fieldTags.BitsPerSample,\n  fieldTags.ExtraSamples,\n  fieldTags.SampleFormat,\n  fieldTags.StripByteCounts,\n  fieldTags.StripOffsets,\n  fieldTags.StripRowCounts,\n  fieldTags.TileByteCounts,\n  fieldTags.TileOffsets,\n  fieldTags.SubIFDs,\n];\n\nexport const fieldTypeNames = {\n  0x0001: 'BYTE',\n  0x0002: 'ASCII',\n  0x0003: 'SHORT',\n  0x0004: 'LONG',\n  0x0005: 'RATIONAL',\n  0x0006: 'SBYTE',\n  0x0007: 'UNDEFINED',\n  0x0008: 'SSHORT',\n  0x0009: 'SLONG',\n  0x000A: 'SRATIONAL',\n  0x000B: 'FLOAT',\n  0x000C: 'DOUBLE',\n  // IFD offset, suggested by https://owl.phy.queensu.ca/~phil/exiftool/standards.html\n  0x000D: 'IFD',\n  // introduced by BigTIFF\n  0x0010: 'LONG8',\n  0x0011: 'SLONG8',\n  0x0012: 'IFD8',\n};\n\nexport const fieldTypes = {};\nfor (const key in fieldTypeNames) {\n  if (fieldTypeNames.hasOwnProperty(key)) {\n    fieldTypes[fieldTypeNames[key]] = parseInt(key, 10);\n  }\n}\n\nexport const photometricInterpretations = {\n  WhiteIsZero: 0,\n  BlackIsZero: 1,\n  RGB: 2,\n  Palette: 3,\n  TransparencyMask: 4,\n  CMYK: 5,\n  YCbCr: 6,\n\n  CIELab: 8,\n  ICCLab: 9,\n};\n\nexport const ExtraSamplesValues = {\n  Unspecified: 0,\n  Assocalpha: 1,\n  Unassalpha: 2,\n};\n\nexport const LercParameters = {\n  Version: 0,\n  AddCompression: 1,\n};\n\nexport const LercAddCompression = {\n  None: 0,\n  Deflate: 1,\n  Zstandard: 2,\n};\n\nexport const geoKeyNames = {\n  1024: 'GTModelTypeGeoKey',\n  1025: 'GTRasterTypeGeoKey',\n  1026: 'GTCitationGeoKey',\n  2048: 'GeographicTypeGeoKey',\n  2049: 'GeogCitationGeoKey',\n  2050: 'GeogGeodeticDatumGeoKey',\n  2051: 'GeogPrimeMeridianGeoKey',\n  2052: 'GeogLinearUnitsGeoKey',\n  2053: 'GeogLinearUnitSizeGeoKey',\n  2054: 'GeogAngularUnitsGeoKey',\n  2055: 'GeogAngularUnitSizeGeoKey',\n  2056: 'GeogEllipsoidGeoKey',\n  2057: 'GeogSemiMajorAxisGeoKey',\n  2058: 'GeogSemiMinorAxisGeoKey',\n  2059: 'GeogInvFlatteningGeoKey',\n  2060: 'GeogAzimuthUnitsGeoKey',\n  2061: 'GeogPrimeMeridianLongGeoKey',\n  2062: 'GeogTOWGS84GeoKey',\n  3072: 'ProjectedCSTypeGeoKey',\n  3073: 'PCSCitationGeoKey',\n  3074: 'ProjectionGeoKey',\n  3075: 'ProjCoordTransGeoKey',\n  3076: 'ProjLinearUnitsGeoKey',\n  3077: 'ProjLinearUnitSizeGeoKey',\n  3078: 'ProjStdParallel1GeoKey',\n  3079: 'ProjStdParallel2GeoKey',\n  3080: 'ProjNatOriginLongGeoKey',\n  3081: 'ProjNatOriginLatGeoKey',\n  3082: 'ProjFalseEastingGeoKey',\n  3083: 'ProjFalseNorthingGeoKey',\n  3084: 'ProjFalseOriginLongGeoKey',\n  3085: 'ProjFalseOriginLatGeoKey',\n  3086: 'ProjFalseOriginEastingGeoKey',\n  3087: 'ProjFalseOriginNorthingGeoKey',\n  3088: 'ProjCenterLongGeoKey',\n  3089: 'ProjCenterLatGeoKey',\n  3090: 'ProjCenterEastingGeoKey',\n  3091: 'ProjCenterNorthingGeoKey',\n  3092: 'ProjScaleAtNatOriginGeoKey',\n  3093: 'ProjScaleAtCenterGeoKey',\n  3094: 'ProjAzimuthAngleGeoKey',\n  3095: 'ProjStraightVertPoleLongGeoKey',\n  3096: 'ProjRectifiedGridAngleGeoKey',\n  4096: 'VerticalCSTypeGeoKey',\n  4097: 'VerticalCitationGeoKey',\n  4098: 'VerticalDatumGeoKey',\n  4099: 'VerticalUnitsGeoKey',\n};\n\nexport const geoKeys = {};\nfor (const key in geoKeyNames) {\n  if (geoKeyNames.hasOwnProperty(key)) {\n    geoKeys[geoKeyNames[key]] = parseInt(key, 10);\n  }\n}\n","export function fromWhiteIsZero(raster, max) {\n  const { width, height } = raster;\n  const rgbRaster = new Uint8Array(width * height * 3);\n  let value;\n  for (let i = 0, j = 0; i < raster.length; ++i, j += 3) {\n    value = 256 - (raster[i] / max * 256);\n    rgbRaster[j] = value;\n    rgbRaster[j + 1] = value;\n    rgbRaster[j + 2] = value;\n  }\n  return rgbRaster;\n}\n\nexport function fromBlackIsZero(raster, max) {\n  const { width, height } = raster;\n  const rgbRaster = new Uint8Array(width * height * 3);\n  let value;\n  for (let i = 0, j = 0; i < raster.length; ++i, j += 3) {\n    value = raster[i] / max * 256;\n    rgbRaster[j] = value;\n    rgbRaster[j + 1] = value;\n    rgbRaster[j + 2] = value;\n  }\n  return rgbRaster;\n}\n\nexport function fromPalette(raster, colorMap) {\n  const { width, height } = raster;\n  const rgbRaster = new Uint8Array(width * height * 3);\n  const greenOffset = colorMap.length / 3;\n  const blueOffset = colorMap.length / 3 * 2;\n  for (let i = 0, j = 0; i < raster.length; ++i, j += 3) {\n    const mapIndex = raster[i];\n    rgbRaster[j] = colorMap[mapIndex] / 65536 * 256;\n    rgbRaster[j + 1] = colorMap[mapIndex + greenOffset] / 65536 * 256;\n    rgbRaster[j + 2] = colorMap[mapIndex + blueOffset] / 65536 * 256;\n  }\n  return rgbRaster;\n}\n\nexport function fromCMYK(cmykRaster) {\n  const { width, height } = cmykRaster;\n  const rgbRaster = new Uint8Array(width * height * 3);\n  for (let i = 0, j = 0; i < cmykRaster.length; i += 4, j += 3) {\n    const c = cmykRaster[i];\n    const m = cmykRaster[i + 1];\n    const y = cmykRaster[i + 2];\n    const k = cmykRaster[i + 3];\n\n    rgbRaster[j] = 255 * ((255 - c) / 256) * ((255 - k) / 256);\n    rgbRaster[j + 1] = 255 * ((255 - m) / 256) * ((255 - k) / 256);\n    rgbRaster[j + 2] = 255 * ((255 - y) / 256) * ((255 - k) / 256);\n  }\n  return rgbRaster;\n}\n\nexport function fromYCbCr(yCbCrRaster) {\n  const { width, height } = yCbCrRaster;\n  const rgbRaster = new Uint8ClampedArray(width * height * 3);\n  for (let i = 0, j = 0; i < yCbCrRaster.length; i += 3, j += 3) {\n    const y = yCbCrRaster[i];\n    const cb = yCbCrRaster[i + 1];\n    const cr = yCbCrRaster[i + 2];\n\n    rgbRaster[j] = (y + (1.40200 * (cr - 0x80)));\n    rgbRaster[j + 1] = (y - (0.34414 * (cb - 0x80)) - (0.71414 * (cr - 0x80)));\n    rgbRaster[j + 2] = (y + (1.77200 * (cb - 0x80)));\n  }\n  return rgbRaster;\n}\n\nconst Xn = 0.95047;\nconst Yn = 1.00000;\nconst Zn = 1.08883;\n\n// from https://github.com/antimatter15/rgb-lab/blob/master/color.js\n\nexport function fromCIELab(cieLabRaster) {\n  const { width, height } = cieLabRaster;\n  const rgbRaster = new Uint8Array(width * height * 3);\n\n  for (let i = 0, j = 0; i < cieLabRaster.length; i += 3, j += 3) {\n    const L = cieLabRaster[i + 0];\n    const a_ = cieLabRaster[i + 1] << 24 >> 24; // conversion from uint8 to int8\n    const b_ = cieLabRaster[i + 2] << 24 >> 24; // same\n\n    let y = (L + 16) / 116;\n    let x = (a_ / 500) + y;\n    let z = y - (b_ / 200);\n    let r;\n    let g;\n    let b;\n\n    x = Xn * ((x * x * x > 0.008856) ? x * x * x : (x - (16 / 116)) / 7.787);\n    y = Yn * ((y * y * y > 0.008856) ? y * y * y : (y - (16 / 116)) / 7.787);\n    z = Zn * ((z * z * z > 0.008856) ? z * z * z : (z - (16 / 116)) / 7.787);\n\n    r = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);\n    g = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);\n    b = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);\n\n    r = (r > 0.0031308) ? ((1.055 * (r ** (1 / 2.4))) - 0.055) : 12.92 * r;\n    g = (g > 0.0031308) ? ((1.055 * (g ** (1 / 2.4))) - 0.055) : 12.92 * g;\n    b = (b > 0.0031308) ? ((1.055 * (b ** (1 / 2.4))) - 0.055) : 12.92 * b;\n\n    rgbRaster[j] = Math.max(0, Math.min(1, r)) * 255;\n    rgbRaster[j + 1] = Math.max(0, Math.min(1, g)) * 255;\n    rgbRaster[j + 2] = Math.max(0, Math.min(1, b)) * 255;\n  }\n  return rgbRaster;\n}\n","const registry = new Map();\n\nexport function addDecoder(cases, importFn) {\n  if (!Array.isArray(cases)) {\n    cases = [cases]; // eslint-disable-line no-param-reassign\n  }\n  cases.forEach((c) => registry.set(c, importFn));\n}\n\nexport async function getDecoder(fileDirectory) {\n  const importFn = registry.get(fileDirectory.Compression);\n  if (!importFn) {\n    throw new Error(`Unknown compression method identifier: ${fileDirectory.Compression}`);\n  }\n  const Decoder = await importFn();\n  return new Decoder(fileDirectory);\n}\n\n// Add default decoders to registry (end-user may override with other implementations)\naddDecoder([undefined, 1], () => import('./raw.js').then((m) => m.default));\naddDecoder(5, () => import('./lzw.js').then((m) => m.default));\naddDecoder(6, () => {\n  throw new Error('old style JPEG compression is not supported.');\n});\naddDecoder(7, () => import('./jpeg.js').then((m) => m.default));\naddDecoder([8, 32946], () => import('./deflate.js').then((m) => m.default));\naddDecoder(32773, () => import('./packbits.js').then((m) => m.default));\naddDecoder(34887, () => import('./lerc.js')\n  .then(async (m) => {\n    await m.zstd.init();\n    return m;\n  })\n  .then((m) => m.default),\n);\naddDecoder(50001, () => import('./webimage.js').then((m) => m.default));\n","/**\n * @module resample\n */\n\nfunction copyNewSize(array, width, height, samplesPerPixel = 1) {\n  return new (Object.getPrototypeOf(array).constructor)(width * height * samplesPerPixel);\n}\n\n/**\n * Resample the input arrays using nearest neighbor value selection.\n * @param {TypedArray[]} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @returns {TypedArray[]} The resampled rasters\n */\nexport function resampleNearest(valueArrays, inWidth, inHeight, outWidth, outHeight) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n  return valueArrays.map((array) => {\n    const newArray = copyNewSize(array, outWidth, outHeight);\n    for (let y = 0; y < outHeight; ++y) {\n      const cy = Math.min(Math.round(relY * y), inHeight - 1);\n      for (let x = 0; x < outWidth; ++x) {\n        const cx = Math.min(Math.round(relX * x), inWidth - 1);\n        const value = array[(cy * inWidth) + cx];\n        newArray[(y * outWidth) + x] = value;\n      }\n    }\n    return newArray;\n  });\n}\n\n// simple linear interpolation, code from:\n// https://en.wikipedia.org/wiki/Linear_interpolation#Programming_language_support\nfunction lerp(v0, v1, t) {\n  return ((1 - t) * v0) + (t * v1);\n}\n\n/**\n * Resample the input arrays using bilinear interpolation.\n * @param {TypedArray[]} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @returns {TypedArray[]} The resampled rasters\n */\nexport function resampleBilinear(valueArrays, inWidth, inHeight, outWidth, outHeight) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n\n  return valueArrays.map((array) => {\n    const newArray = copyNewSize(array, outWidth, outHeight);\n    for (let y = 0; y < outHeight; ++y) {\n      const rawY = relY * y;\n\n      const yl = Math.floor(rawY);\n      const yh = Math.min(Math.ceil(rawY), (inHeight - 1));\n\n      for (let x = 0; x < outWidth; ++x) {\n        const rawX = relX * x;\n        const tx = rawX % 1;\n\n        const xl = Math.floor(rawX);\n        const xh = Math.min(Math.ceil(rawX), (inWidth - 1));\n\n        const ll = array[(yl * inWidth) + xl];\n        const hl = array[(yl * inWidth) + xh];\n        const lh = array[(yh * inWidth) + xl];\n        const hh = array[(yh * inWidth) + xh];\n\n        const value = lerp(\n          lerp(ll, hl, tx),\n          lerp(lh, hh, tx),\n          rawY % 1,\n        );\n        newArray[(y * outWidth) + x] = value;\n      }\n    }\n    return newArray;\n  });\n}\n\n/**\n * Resample the input arrays using the selected resampling method.\n * @param {TypedArray[]} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {string} [method = 'nearest'] The desired resampling method\n * @returns {TypedArray[]} The resampled rasters\n */\nexport function resample(valueArrays, inWidth, inHeight, outWidth, outHeight, method = 'nearest') {\n  switch (method.toLowerCase()) {\n    case 'nearest':\n      return resampleNearest(valueArrays, inWidth, inHeight, outWidth, outHeight);\n    case 'bilinear':\n    case 'linear':\n      return resampleBilinear(valueArrays, inWidth, inHeight, outWidth, outHeight);\n    default:\n      throw new Error(`Unsupported resampling method: '${method}'`);\n  }\n}\n\n/**\n * Resample the pixel interleaved input array using nearest neighbor value selection.\n * @param {TypedArray} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {number} samples The number of samples per pixel for pixel\n *                         interleaved data\n * @returns {TypedArray} The resampled raster\n */\nexport function resampleNearestInterleaved(\n  valueArray, inWidth, inHeight, outWidth, outHeight, samples) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n\n  const newArray = copyNewSize(valueArray, outWidth, outHeight, samples);\n  for (let y = 0; y < outHeight; ++y) {\n    const cy = Math.min(Math.round(relY * y), inHeight - 1);\n    for (let x = 0; x < outWidth; ++x) {\n      const cx = Math.min(Math.round(relX * x), inWidth - 1);\n      for (let i = 0; i < samples; ++i) {\n        const value = valueArray[(cy * inWidth * samples) + (cx * samples) + i];\n        newArray[(y * outWidth * samples) + (x * samples) + i] = value;\n      }\n    }\n  }\n  return newArray;\n}\n\n/**\n * Resample the pixel interleaved input array using bilinear interpolation.\n * @param {TypedArray} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {number} samples The number of samples per pixel for pixel\n *                         interleaved data\n * @returns {TypedArray} The resampled raster\n */\nexport function resampleBilinearInterleaved(\n  valueArray, inWidth, inHeight, outWidth, outHeight, samples) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n  const newArray = copyNewSize(valueArray, outWidth, outHeight, samples);\n  for (let y = 0; y < outHeight; ++y) {\n    const rawY = relY * y;\n\n    const yl = Math.floor(rawY);\n    const yh = Math.min(Math.ceil(rawY), (inHeight - 1));\n\n    for (let x = 0; x < outWidth; ++x) {\n      const rawX = relX * x;\n      const tx = rawX % 1;\n\n      const xl = Math.floor(rawX);\n      const xh = Math.min(Math.ceil(rawX), (inWidth - 1));\n\n      for (let i = 0; i < samples; ++i) {\n        const ll = valueArray[(yl * inWidth * samples) + (xl * samples) + i];\n        const hl = valueArray[(yl * inWidth * samples) + (xh * samples) + i];\n        const lh = valueArray[(yh * inWidth * samples) + (xl * samples) + i];\n        const hh = valueArray[(yh * inWidth * samples) + (xh * samples) + i];\n\n        const value = lerp(\n          lerp(ll, hl, tx),\n          lerp(lh, hh, tx),\n          rawY % 1,\n        );\n        newArray[(y * outWidth * samples) + (x * samples) + i] = value;\n      }\n    }\n  }\n  return newArray;\n}\n\n/**\n * Resample the pixel interleaved input array using the selected resampling method.\n * @param {TypedArray} valueArray The input array to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {number} samples The number of samples per pixel for pixel\n *                                 interleaved data\n * @param {string} [method = 'nearest'] The desired resampling method\n * @returns {TypedArray} The resampled rasters\n */\nexport function resampleInterleaved(valueArray, inWidth, inHeight, outWidth, outHeight, samples, method = 'nearest') {\n  switch (method.toLowerCase()) {\n    case 'nearest':\n      return resampleNearestInterleaved(\n        valueArray, inWidth, inHeight, outWidth, outHeight, samples,\n      );\n    case 'bilinear':\n    case 'linear':\n      return resampleBilinearInterleaved(\n        valueArray, inWidth, inHeight, outWidth, outHeight, samples,\n      );\n    default:\n      throw new Error(`Unsupported resampling method: '${method}'`);\n  }\n}\n","/** @module geotiffimage */\nimport { getFloat16 } from '@petamoriken/float16';\nimport getAttribute from 'xml-utils/get-attribute.js';\nimport findTagsByName from 'xml-utils/find-tags-by-name.js';\n\nimport { photometricInterpretations, ExtraSamplesValues } from './globals.js';\nimport { fromWhiteIsZero, fromBlackIsZero, fromPalette, fromCMYK, fromYCbCr, fromCIELab } from './rgb.js';\nimport { getDecoder } from './compression/index.js';\nimport { resample, resampleInterleaved } from './resample.js';\n\n/**\n * @typedef {Object} ReadRasterOptions\n * @property {Array<number>} [window=whole window] the subset to read data from in pixels.\n * @property {Array<number>} [bbox=whole image] the subset to read data from in\n *                                           geographical coordinates.\n * @property {Array<number>} [samples=all samples] the selection of samples to read from. Default is all samples.\n * @property {boolean} [interleave=false] whether the data shall be read\n *                                             in one single array or separate\n *                                             arrays.\n * @property {Pool} [pool=null] The optional decoder pool to use.\n * @property {number} [width] The desired width of the output. When the width is not the\n *                                 same as the images, resampling will be performed.\n * @property {number} [height] The desired height of the output. When the width is not the\n *                                  same as the images, resampling will be performed.\n * @property {string} [resampleMethod='nearest'] The desired resampling method.\n * @property {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                                       to be aborted\n * @property {number|number[]} [fillValue] The value to use for parts of the image\n *                                              outside of the images extent. When multiple\n *                                              samples are requested, an array of fill values\n *                                              can be passed.\n */\n\n/** @typedef {import(\"./geotiff.js\").TypedArray} TypedArray */\n/** @typedef {import(\"./geotiff.js\").ReadRasterResult} ReadRasterResult */\n\nfunction sum(array, start, end) {\n  let s = 0;\n  for (let i = start; i < end; ++i) {\n    s += array[i];\n  }\n  return s;\n}\n\nfunction arrayForType(format, bitsPerSample, size) {\n  switch (format) {\n    case 1: // unsigned integer data\n      if (bitsPerSample <= 8) {\n        return new Uint8Array(size);\n      } else if (bitsPerSample <= 16) {\n        return new Uint16Array(size);\n      } else if (bitsPerSample <= 32) {\n        return new Uint32Array(size);\n      }\n      break;\n    case 2: // twos complement signed integer data\n      if (bitsPerSample === 8) {\n        return new Int8Array(size);\n      } else if (bitsPerSample === 16) {\n        return new Int16Array(size);\n      } else if (bitsPerSample === 32) {\n        return new Int32Array(size);\n      }\n      break;\n    case 3: // floating point data\n      switch (bitsPerSample) {\n        case 16:\n        case 32:\n          return new Float32Array(size);\n        case 64:\n          return new Float64Array(size);\n        default:\n          break;\n      }\n      break;\n    default:\n      break;\n  }\n  throw Error('Unsupported data format/bitsPerSample');\n}\n\nfunction needsNormalization(format, bitsPerSample) {\n  if ((format === 1 || format === 2) && bitsPerSample <= 32 && bitsPerSample % 8 === 0) {\n    return false;\n  } else if (format === 3 && (bitsPerSample === 16 || bitsPerSample === 32 || bitsPerSample === 64)) {\n    return false;\n  }\n  return true;\n}\n\nfunction normalizeArray(inBuffer, format, planarConfiguration, samplesPerPixel, bitsPerSample, tileWidth, tileHeight) {\n  // const inByteArray = new Uint8Array(inBuffer);\n  const view = new DataView(inBuffer);\n  const outSize = planarConfiguration === 2\n    ? tileHeight * tileWidth\n    : tileHeight * tileWidth * samplesPerPixel;\n  const samplesToTransfer = planarConfiguration === 2\n    ? 1 : samplesPerPixel;\n  const outArray = arrayForType(format, bitsPerSample, outSize);\n  // let pixel = 0;\n\n  const bitMask = parseInt('1'.repeat(bitsPerSample), 2);\n\n  if (format === 1) { // unsigned integer\n    // translation of https://github.com/OSGeo/gdal/blob/master/gdal/frmts/gtiff/geotiff.cpp#L7337\n    let pixelBitSkip;\n    // let sampleBitOffset = 0;\n    if (planarConfiguration === 1) {\n      pixelBitSkip = samplesPerPixel * bitsPerSample;\n      // sampleBitOffset = (samplesPerPixel - 1) * bitsPerSample;\n    } else {\n      pixelBitSkip = bitsPerSample;\n    }\n\n    // Bits per line rounds up to next byte boundary.\n    let bitsPerLine = tileWidth * pixelBitSkip;\n    if ((bitsPerLine & 7) !== 0) {\n      bitsPerLine = (bitsPerLine + 7) & (~7);\n    }\n\n    for (let y = 0; y < tileHeight; ++y) {\n      const lineBitOffset = y * bitsPerLine;\n      for (let x = 0; x < tileWidth; ++x) {\n        const pixelBitOffset = lineBitOffset + (x * samplesToTransfer * bitsPerSample);\n        for (let i = 0; i < samplesToTransfer; ++i) {\n          const bitOffset = pixelBitOffset + (i * bitsPerSample);\n          const outIndex = (((y * tileWidth) + x) * samplesToTransfer) + i;\n\n          const byteOffset = Math.floor(bitOffset / 8);\n          const innerBitOffset = bitOffset % 8;\n          if (innerBitOffset + bitsPerSample <= 8) {\n            outArray[outIndex] = (view.getUint8(byteOffset) >> (8 - bitsPerSample) - innerBitOffset) & bitMask;\n          } else if (innerBitOffset + bitsPerSample <= 16) {\n            outArray[outIndex] = (view.getUint16(byteOffset) >> (16 - bitsPerSample) - innerBitOffset) & bitMask;\n          } else if (innerBitOffset + bitsPerSample <= 24) {\n            const raw = (view.getUint16(byteOffset) << 8) | (view.getUint8(byteOffset + 2));\n            outArray[outIndex] = (raw >> (24 - bitsPerSample) - innerBitOffset) & bitMask;\n          } else {\n            outArray[outIndex] = (view.getUint32(byteOffset) >> (32 - bitsPerSample) - innerBitOffset) & bitMask;\n          }\n\n          // let outWord = 0;\n          // for (let bit = 0; bit < bitsPerSample; ++bit) {\n          //   if (inByteArray[bitOffset >> 3]\n          //     & (0x80 >> (bitOffset & 7))) {\n          //     outWord |= (1 << (bitsPerSample - 1 - bit));\n          //   }\n          //   ++bitOffset;\n          // }\n\n          // outArray[outIndex] = outWord;\n          // outArray[pixel] = outWord;\n          // pixel += 1;\n        }\n        // bitOffset = bitOffset + pixelBitSkip - bitsPerSample;\n      }\n    }\n  } else if (format === 3) { // floating point\n    // Float16 is handled elsewhere\n    // normalize 16/24 bit floats to 32 bit floats in the array\n    // console.time();\n    // if (bitsPerSample === 16) {\n    //   for (let byte = 0, outIndex = 0; byte < inBuffer.byteLength; byte += 2, ++outIndex) {\n    //     outArray[outIndex] = getFloat16(view, byte);\n    //   }\n    // }\n    // console.timeEnd()\n  }\n\n  return outArray.buffer;\n}\n\n/**\n * GeoTIFF sub-file image.\n */\nclass GeoTIFFImage {\n  /**\n   * @constructor\n   * @param {Object} fileDirectory The parsed file directory\n   * @param {Object} geoKeys The parsed geo-keys\n   * @param {DataView} dataView The DataView for the underlying file.\n   * @param {Boolean} littleEndian Whether the file is encoded in little or big endian\n   * @param {Boolean} cache Whether or not decoded tiles shall be cached\n   * @param {import('./source/basesource').BaseSource} source The datasource to read from\n   */\n  constructor(fileDirectory, geoKeys, dataView, littleEndian, cache, source) {\n    this.fileDirectory = fileDirectory;\n    this.geoKeys = geoKeys;\n    this.dataView = dataView;\n    this.littleEndian = littleEndian;\n    this.tiles = cache ? {} : null;\n    this.isTiled = !fileDirectory.StripOffsets;\n    const planarConfiguration = fileDirectory.PlanarConfiguration;\n    this.planarConfiguration = (typeof planarConfiguration === 'undefined') ? 1 : planarConfiguration;\n    if (this.planarConfiguration !== 1 && this.planarConfiguration !== 2) {\n      throw new Error('Invalid planar configuration.');\n    }\n\n    this.source = source;\n  }\n\n  /**\n   * Returns the associated parsed file directory.\n   * @returns {Object} the parsed file directory\n   */\n  getFileDirectory() {\n    return this.fileDirectory;\n  }\n\n  /**\n   * Returns the associated parsed geo keys.\n   * @returns {Object} the parsed geo keys\n   */\n  getGeoKeys() {\n    return this.geoKeys;\n  }\n\n  /**\n   * Returns the width of the image.\n   * @returns {Number} the width of the image\n   */\n  getWidth() {\n    return this.fileDirectory.ImageWidth;\n  }\n\n  /**\n   * Returns the height of the image.\n   * @returns {Number} the height of the image\n   */\n  getHeight() {\n    return this.fileDirectory.ImageLength;\n  }\n\n  /**\n   * Returns the number of samples per pixel.\n   * @returns {Number} the number of samples per pixel\n   */\n  getSamplesPerPixel() {\n    return typeof this.fileDirectory.SamplesPerPixel !== 'undefined'\n      ? this.fileDirectory.SamplesPerPixel : 1;\n  }\n\n  /**\n   * Returns the width of each tile.\n   * @returns {Number} the width of each tile\n   */\n  getTileWidth() {\n    return this.isTiled ? this.fileDirectory.TileWidth : this.getWidth();\n  }\n\n  /**\n   * Returns the height of each tile.\n   * @returns {Number} the height of each tile\n   */\n  getTileHeight() {\n    if (this.isTiled) {\n      return this.fileDirectory.TileLength;\n    }\n    if (typeof this.fileDirectory.RowsPerStrip !== 'undefined') {\n      return Math.min(this.fileDirectory.RowsPerStrip, this.getHeight());\n    }\n    return this.getHeight();\n  }\n\n  getBlockWidth() {\n    return this.getTileWidth();\n  }\n\n  getBlockHeight(y) {\n    if (this.isTiled || (y + 1) * this.getTileHeight() <= this.getHeight()) {\n      return this.getTileHeight();\n    } else {\n      return this.getHeight() - (y * this.getTileHeight());\n    }\n  }\n\n  /**\n   * Calculates the number of bytes for each pixel across all samples. Only full\n   * bytes are supported, an exception is thrown when this is not the case.\n   * @returns {Number} the bytes per pixel\n   */\n  getBytesPerPixel() {\n    let bytes = 0;\n    for (let i = 0; i < this.fileDirectory.BitsPerSample.length; ++i) {\n      bytes += this.getSampleByteSize(i);\n    }\n    return bytes;\n  }\n\n  getSampleByteSize(i) {\n    if (i >= this.fileDirectory.BitsPerSample.length) {\n      throw new RangeError(`Sample index ${i} is out of range.`);\n    }\n    return Math.ceil(this.fileDirectory.BitsPerSample[i] / 8);\n  }\n\n  getReaderForSample(sampleIndex) {\n    const format = this.fileDirectory.SampleFormat\n      ? this.fileDirectory.SampleFormat[sampleIndex] : 1;\n    const bitsPerSample = this.fileDirectory.BitsPerSample[sampleIndex];\n    switch (format) {\n      case 1: // unsigned integer data\n        if (bitsPerSample <= 8) {\n          return DataView.prototype.getUint8;\n        } else if (bitsPerSample <= 16) {\n          return DataView.prototype.getUint16;\n        } else if (bitsPerSample <= 32) {\n          return DataView.prototype.getUint32;\n        }\n        break;\n      case 2: // twos complement signed integer data\n        if (bitsPerSample <= 8) {\n          return DataView.prototype.getInt8;\n        } else if (bitsPerSample <= 16) {\n          return DataView.prototype.getInt16;\n        } else if (bitsPerSample <= 32) {\n          return DataView.prototype.getInt32;\n        }\n        break;\n      case 3:\n        switch (bitsPerSample) {\n          case 16:\n            return function (offset, littleEndian) {\n              return getFloat16(this, offset, littleEndian);\n            };\n          case 32:\n            return DataView.prototype.getFloat32;\n          case 64:\n            return DataView.prototype.getFloat64;\n          default:\n            break;\n        }\n        break;\n      default:\n        break;\n    }\n    throw Error('Unsupported data format/bitsPerSample');\n  }\n\n  getSampleFormat(sampleIndex = 0) {\n    return this.fileDirectory.SampleFormat\n      ? this.fileDirectory.SampleFormat[sampleIndex] : 1;\n  }\n\n  getBitsPerSample(sampleIndex = 0) {\n    return this.fileDirectory.BitsPerSample[sampleIndex];\n  }\n\n  getArrayForSample(sampleIndex, size) {\n    const format = this.getSampleFormat(sampleIndex);\n    const bitsPerSample = this.getBitsPerSample(sampleIndex);\n    return arrayForType(format, bitsPerSample, size);\n  }\n\n  /**\n   * Returns the decoded strip or tile.\n   * @param {Number} x the strip or tile x-offset\n   * @param {Number} y the tile y-offset (0 for stripped images)\n   * @param {Number} sample the sample to get for separated samples\n   * @param {import(\"./geotiff\").Pool|import(\"./geotiff\").BaseDecoder} poolOrDecoder the decoder or decoder pool\n   * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n   *                               to be aborted\n   * @returns {Promise.<ArrayBuffer>}\n   */\n  async getTileOrStrip(x, y, sample, poolOrDecoder, signal) {\n    const numTilesPerRow = Math.ceil(this.getWidth() / this.getTileWidth());\n    const numTilesPerCol = Math.ceil(this.getHeight() / this.getTileHeight());\n    let index;\n    const { tiles } = this;\n    if (this.planarConfiguration === 1) {\n      index = (y * numTilesPerRow) + x;\n    } else if (this.planarConfiguration === 2) {\n      index = (sample * numTilesPerRow * numTilesPerCol) + (y * numTilesPerRow) + x;\n    }\n\n    let offset;\n    let byteCount;\n    if (this.isTiled) {\n      offset = this.fileDirectory.TileOffsets[index];\n      byteCount = this.fileDirectory.TileByteCounts[index];\n    } else {\n      offset = this.fileDirectory.StripOffsets[index];\n      byteCount = this.fileDirectory.StripByteCounts[index];\n    }\n    const slice = (await this.source.fetch([{ offset, length: byteCount }], signal))[0];\n\n    let request;\n    if (tiles === null || !tiles[index]) {\n    // resolve each request by potentially applying array normalization\n      request = (async () => {\n        let data = await poolOrDecoder.decode(this.fileDirectory, slice);\n        const sampleFormat = this.getSampleFormat();\n        const bitsPerSample = this.getBitsPerSample();\n        if (needsNormalization(sampleFormat, bitsPerSample)) {\n          data = normalizeArray(\n            data,\n            sampleFormat,\n            this.planarConfiguration,\n            this.getSamplesPerPixel(),\n            bitsPerSample,\n            this.getTileWidth(),\n            this.getBlockHeight(y),\n          );\n        }\n        return data;\n      })();\n\n      // set the cache\n      if (tiles !== null) {\n        tiles[index] = request;\n      }\n    } else {\n      // get from the cache\n      request = tiles[index];\n    }\n\n    // cache the tile request\n    return { x, y, sample, data: await request };\n  }\n\n  /**\n   * Internal read function.\n   * @private\n   * @param {Array} imageWindow The image window in pixel coordinates\n   * @param {Array} samples The selected samples (0-based indices)\n   * @param {TypedArray|TypedArray[]} valueArrays The array(s) to write into\n   * @param {Boolean} interleave Whether or not to write in an interleaved manner\n   * @param {import(\"./geotiff\").Pool|AbstractDecoder} poolOrDecoder the decoder or decoder pool\n   * @param {number} width the width of window to be read into\n   * @param {number} height the height of window to be read into\n   * @param {number} resampleMethod the resampling method to be used when interpolating\n   * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n   *                               to be aborted\n   * @returns {Promise<ReadRasterResult>}\n   */\n  async _readRaster(imageWindow, samples, valueArrays, interleave, poolOrDecoder, width,\n    height, resampleMethod, signal) {\n    const tileWidth = this.getTileWidth();\n    const tileHeight = this.getTileHeight();\n    const imageWidth = this.getWidth();\n    const imageHeight = this.getHeight();\n\n    const minXTile = Math.max(Math.floor(imageWindow[0] / tileWidth), 0);\n    const maxXTile = Math.min(\n      Math.ceil(imageWindow[2] / tileWidth),\n      Math.ceil(imageWidth / tileWidth),\n    );\n    const minYTile = Math.max(Math.floor(imageWindow[1] / tileHeight), 0);\n    const maxYTile = Math.min(\n      Math.ceil(imageWindow[3] / tileHeight),\n      Math.ceil(imageHeight / tileHeight),\n    );\n    const windowWidth = imageWindow[2] - imageWindow[0];\n\n    let bytesPerPixel = this.getBytesPerPixel();\n\n    const srcSampleOffsets = [];\n    const sampleReaders = [];\n    for (let i = 0; i < samples.length; ++i) {\n      if (this.planarConfiguration === 1) {\n        srcSampleOffsets.push(sum(this.fileDirectory.BitsPerSample, 0, samples[i]) / 8);\n      } else {\n        srcSampleOffsets.push(0);\n      }\n      sampleReaders.push(this.getReaderForSample(samples[i]));\n    }\n\n    const promises = [];\n    const { littleEndian } = this;\n\n    for (let yTile = minYTile; yTile < maxYTile; ++yTile) {\n      for (let xTile = minXTile; xTile < maxXTile; ++xTile) {\n        let getPromise;\n        if (this.planarConfiguration === 1) {\n          getPromise = this.getTileOrStrip(xTile, yTile, 0, poolOrDecoder, signal);\n        }\n        for (let sampleIndex = 0; sampleIndex < samples.length; ++sampleIndex) {\n          const si = sampleIndex;\n          const sample = samples[sampleIndex];\n          if (this.planarConfiguration === 2) {\n            bytesPerPixel = this.getSampleByteSize(sample);\n            getPromise = this.getTileOrStrip(xTile, yTile, sample, poolOrDecoder, signal);\n          }\n          const promise = getPromise.then((tile) => {\n            const buffer = tile.data;\n            const dataView = new DataView(buffer);\n            const blockHeight = this.getBlockHeight(tile.y);\n            const firstLine = tile.y * tileHeight;\n            const firstCol = tile.x * tileWidth;\n            const lastLine = firstLine + blockHeight;\n            const lastCol = (tile.x + 1) * tileWidth;\n            const reader = sampleReaders[si];\n\n            const ymax = Math.min(blockHeight, blockHeight - (lastLine - imageWindow[3]), imageHeight - firstLine);\n            const xmax = Math.min(tileWidth, tileWidth - (lastCol - imageWindow[2]), imageWidth - firstCol);\n\n            for (let y = Math.max(0, imageWindow[1] - firstLine); y < ymax; ++y) {\n              for (let x = Math.max(0, imageWindow[0] - firstCol); x < xmax; ++x) {\n                const pixelOffset = ((y * tileWidth) + x) * bytesPerPixel;\n                const value = reader.call(\n                  dataView, pixelOffset + srcSampleOffsets[si], littleEndian,\n                );\n                let windowCoordinate;\n                if (interleave) {\n                  windowCoordinate = ((y + firstLine - imageWindow[1]) * windowWidth * samples.length)\n                    + ((x + firstCol - imageWindow[0]) * samples.length)\n                    + si;\n                  valueArrays[windowCoordinate] = value;\n                } else {\n                  windowCoordinate = (\n                    (y + firstLine - imageWindow[1]) * windowWidth\n                  ) + x + firstCol - imageWindow[0];\n                  valueArrays[si][windowCoordinate] = value;\n                }\n              }\n            }\n          });\n          promises.push(promise);\n        }\n      }\n    }\n    await Promise.all(promises);\n\n    if ((width && (imageWindow[2] - imageWindow[0]) !== width)\n        || (height && (imageWindow[3] - imageWindow[1]) !== height)) {\n      let resampled;\n      if (interleave) {\n        resampled = resampleInterleaved(\n          valueArrays,\n          imageWindow[2] - imageWindow[0],\n          imageWindow[3] - imageWindow[1],\n          width, height,\n          samples.length,\n          resampleMethod,\n        );\n      } else {\n        resampled = resample(\n          valueArrays,\n          imageWindow[2] - imageWindow[0],\n          imageWindow[3] - imageWindow[1],\n          width, height,\n          resampleMethod,\n        );\n      }\n      resampled.width = width;\n      resampled.height = height;\n      return resampled;\n    }\n\n    valueArrays.width = width || imageWindow[2] - imageWindow[0];\n    valueArrays.height = height || imageWindow[3] - imageWindow[1];\n\n    return valueArrays;\n  }\n\n  /**\n   * Reads raster data from the image. This function reads all selected samples\n   * into separate arrays of the correct type for that sample or into a single\n   * combined array when `interleave` is set. When provided, only a subset\n   * of the raster is read for each sample.\n   *\n   * @param {ReadRasterOptions} [options={}] optional parameters\n   * @returns {Promise<ReadRasterResult>} the decoded arrays as a promise\n   */\n  async readRasters({\n    window: wnd, samples = [], interleave, pool = null,\n    width, height, resampleMethod, fillValue, signal,\n  } = {}) {\n    const imageWindow = wnd || [0, 0, this.getWidth(), this.getHeight()];\n\n    // check parameters\n    if (imageWindow[0] > imageWindow[2] || imageWindow[1] > imageWindow[3]) {\n      throw new Error('Invalid subsets');\n    }\n\n    const imageWindowWidth = imageWindow[2] - imageWindow[0];\n    const imageWindowHeight = imageWindow[3] - imageWindow[1];\n    const numPixels = imageWindowWidth * imageWindowHeight;\n    const samplesPerPixel = this.getSamplesPerPixel();\n\n    if (!samples || !samples.length) {\n      for (let i = 0; i < samplesPerPixel; ++i) {\n        samples.push(i);\n      }\n    } else {\n      for (let i = 0; i < samples.length; ++i) {\n        if (samples[i] >= samplesPerPixel) {\n          return Promise.reject(new RangeError(`Invalid sample index '${samples[i]}'.`));\n        }\n      }\n    }\n    let valueArrays;\n    if (interleave) {\n      const format = this.fileDirectory.SampleFormat\n        ? Math.max.apply(null, this.fileDirectory.SampleFormat) : 1;\n      const bitsPerSample = Math.max.apply(null, this.fileDirectory.BitsPerSample);\n      valueArrays = arrayForType(format, bitsPerSample, numPixels * samples.length);\n      if (fillValue) {\n        valueArrays.fill(fillValue);\n      }\n    } else {\n      valueArrays = [];\n      for (let i = 0; i < samples.length; ++i) {\n        const valueArray = this.getArrayForSample(samples[i], numPixels);\n        if (Array.isArray(fillValue) && i < fillValue.length) {\n          valueArray.fill(fillValue[i]);\n        } else if (fillValue && !Array.isArray(fillValue)) {\n          valueArray.fill(fillValue);\n        }\n        valueArrays.push(valueArray);\n      }\n    }\n\n    const poolOrDecoder = pool || await getDecoder(this.fileDirectory);\n\n    const result = await this._readRaster(\n      imageWindow, samples, valueArrays, interleave, poolOrDecoder, width, height, resampleMethod, signal,\n    );\n    return result;\n  }\n\n  /**\n   * Reads raster data from the image as RGB. The result is always an\n   * interleaved typed array.\n   * Colorspaces other than RGB will be transformed to RGB, color maps expanded.\n   * When no other method is applicable, the first sample is used to produce a\n   * grayscale image.\n   * When provided, only a subset of the raster is read for each sample.\n   *\n   * @param {Object} [options] optional parameters\n   * @param {Array<number>} [options.window] the subset to read data from in pixels.\n   * @param {boolean} [options.interleave=true] whether the data shall be read\n   *                                             in one single array or separate\n   *                                             arrays.\n   * @param {import(\"./geotiff\").Pool} [options.pool=null] The optional decoder pool to use.\n   * @param {number} [options.width] The desired width of the output. When the width is no the\n   *                                 same as the images, resampling will be performed.\n   * @param {number} [options.height] The desired height of the output. When the width is no the\n   *                                  same as the images, resampling will be performed.\n   * @param {string} [options.resampleMethod='nearest'] The desired resampling method.\n   * @param {boolean} [options.enableAlpha=false] Enable reading alpha channel if present.\n   * @param {AbortSignal} [options.signal] An AbortSignal that may be signalled if the request is\n   *                                       to be aborted\n   * @returns {Promise<ReadRasterResult>} the RGB array as a Promise\n   */\n  async readRGB({ window, interleave = true, pool = null, width, height,\n    resampleMethod, enableAlpha = false, signal } = {}) {\n    const imageWindow = window || [0, 0, this.getWidth(), this.getHeight()];\n\n    // check parameters\n    if (imageWindow[0] > imageWindow[2] || imageWindow[1] > imageWindow[3]) {\n      throw new Error('Invalid subsets');\n    }\n\n    const pi = this.fileDirectory.PhotometricInterpretation;\n\n    if (pi === photometricInterpretations.RGB) {\n      let s = [0, 1, 2];\n      if ((!(this.fileDirectory.ExtraSamples === ExtraSamplesValues.Unspecified)) && enableAlpha) {\n        s = [];\n        for (let i = 0; i < this.fileDirectory.BitsPerSample.length; i += 1) {\n          s.push(i);\n        }\n      }\n      return this.readRasters({\n        window,\n        interleave,\n        samples: s,\n        pool,\n        width,\n        height,\n        resampleMethod,\n        signal,\n      });\n    }\n\n    let samples;\n    switch (pi) {\n      case photometricInterpretations.WhiteIsZero:\n      case photometricInterpretations.BlackIsZero:\n      case photometricInterpretations.Palette:\n        samples = [0];\n        break;\n      case photometricInterpretations.CMYK:\n        samples = [0, 1, 2, 3];\n        break;\n      case photometricInterpretations.YCbCr:\n      case photometricInterpretations.CIELab:\n        samples = [0, 1, 2];\n        break;\n      default:\n        throw new Error('Invalid or unsupported photometric interpretation.');\n    }\n\n    const subOptions = {\n      window: imageWindow,\n      interleave: true,\n      samples,\n      pool,\n      width,\n      height,\n      resampleMethod,\n      signal,\n    };\n    const { fileDirectory } = this;\n    const raster = await this.readRasters(subOptions);\n\n    const max = 2 ** this.fileDirectory.BitsPerSample[0];\n    let data;\n    switch (pi) {\n      case photometricInterpretations.WhiteIsZero:\n        data = fromWhiteIsZero(raster, max);\n        break;\n      case photometricInterpretations.BlackIsZero:\n        data = fromBlackIsZero(raster, max);\n        break;\n      case photometricInterpretations.Palette:\n        data = fromPalette(raster, fileDirectory.ColorMap);\n        break;\n      case photometricInterpretations.CMYK:\n        data = fromCMYK(raster);\n        break;\n      case photometricInterpretations.YCbCr:\n        data = fromYCbCr(raster);\n        break;\n      case photometricInterpretations.CIELab:\n        data = fromCIELab(raster);\n        break;\n      default:\n        throw new Error('Unsupported photometric interpretation.');\n    }\n\n    // if non-interleaved data is requested, we must split the channels\n    // into their respective arrays\n    if (!interleave) {\n      const red = new Uint8Array(data.length / 3);\n      const green = new Uint8Array(data.length / 3);\n      const blue = new Uint8Array(data.length / 3);\n      for (let i = 0, j = 0; i < data.length; i += 3, ++j) {\n        red[j] = data[i];\n        green[j] = data[i + 1];\n        blue[j] = data[i + 2];\n      }\n      data = [red, green, blue];\n    }\n\n    data.width = raster.width;\n    data.height = raster.height;\n    return data;\n  }\n\n  /**\n   * Returns an array of tiepoints.\n   * @returns {Object[]}\n   */\n  getTiePoints() {\n    if (!this.fileDirectory.ModelTiepoint) {\n      return [];\n    }\n\n    const tiePoints = [];\n    for (let i = 0; i < this.fileDirectory.ModelTiepoint.length; i += 6) {\n      tiePoints.push({\n        i: this.fileDirectory.ModelTiepoint[i],\n        j: this.fileDirectory.ModelTiepoint[i + 1],\n        k: this.fileDirectory.ModelTiepoint[i + 2],\n        x: this.fileDirectory.ModelTiepoint[i + 3],\n        y: this.fileDirectory.ModelTiepoint[i + 4],\n        z: this.fileDirectory.ModelTiepoint[i + 5],\n      });\n    }\n    return tiePoints;\n  }\n\n  /**\n   * Returns the parsed GDAL metadata items.\n   *\n   * If sample is passed to null, dataset-level metadata will be returned.\n   * Otherwise only metadata specific to the provided sample will be returned.\n   *\n   * @param {number} [sample=null] The sample index.\n   * @returns {Object}\n   */\n  getGDALMetadata(sample = null) {\n    const metadata = {};\n    if (!this.fileDirectory.GDAL_METADATA) {\n      return null;\n    }\n    const string = this.fileDirectory.GDAL_METADATA;\n\n    let items = findTagsByName(string, 'Item');\n\n    if (sample === null) {\n      items = items.filter((item) => getAttribute(item, 'sample') === undefined);\n    } else {\n      items = items.filter((item) => Number(getAttribute(item, 'sample')) === sample);\n    }\n\n    for (let i = 0; i < items.length; ++i) {\n      const item = items[i];\n      metadata[getAttribute(item, 'name')] = item.inner;\n    }\n    return metadata;\n  }\n\n  /**\n   * Returns the GDAL nodata value\n   * @returns {number|null}\n   */\n  getGDALNoData() {\n    if (!this.fileDirectory.GDAL_NODATA) {\n      return null;\n    }\n    const string = this.fileDirectory.GDAL_NODATA;\n    return Number(string.substring(0, string.length - 1));\n  }\n\n  /**\n   * Returns the image origin as a XYZ-vector. When the image has no affine\n   * transformation, then an exception is thrown.\n   * @returns {Array<number>} The origin as a vector\n   */\n  getOrigin() {\n    const tiePoints = this.fileDirectory.ModelTiepoint;\n    const modelTransformation = this.fileDirectory.ModelTransformation;\n    if (tiePoints && tiePoints.length === 6) {\n      return [\n        tiePoints[3],\n        tiePoints[4],\n        tiePoints[5],\n      ];\n    }\n    if (modelTransformation) {\n      return [\n        modelTransformation[3],\n        modelTransformation[7],\n        modelTransformation[11],\n      ];\n    }\n    throw new Error('The image does not have an affine transformation.');\n  }\n\n  /**\n   * Returns the image resolution as a XYZ-vector. When the image has no affine\n   * transformation, then an exception is thrown.\n   * @param {GeoTIFFImage} [referenceImage=null] A reference image to calculate the resolution from\n   *                                             in cases when the current image does not have the\n   *                                             required tags on its own.\n   * @returns {Array<number>} The resolution as a vector\n   */\n  getResolution(referenceImage = null) {\n    const modelPixelScale = this.fileDirectory.ModelPixelScale;\n    const modelTransformation = this.fileDirectory.ModelTransformation;\n\n    if (modelPixelScale) {\n      return [\n        modelPixelScale[0],\n        -modelPixelScale[1],\n        modelPixelScale[2],\n      ];\n    }\n    if (modelTransformation) {\n      if (modelTransformation[1] === 0 && modelTransformation[4] === 0) {\n        return [\n          modelTransformation[0],\n          -modelTransformation[5],\n          modelTransformation[10],\n        ];\n      }\n      return [\n        Math.sqrt((modelTransformation[0] * modelTransformation[0])\n          + (modelTransformation[4] * modelTransformation[4])),\n        -Math.sqrt((modelTransformation[1] * modelTransformation[1])\n          + (modelTransformation[5] * modelTransformation[5])),\n        modelTransformation[10]];\n    }\n\n    if (referenceImage) {\n      const [refResX, refResY, refResZ] = referenceImage.getResolution();\n      return [\n        refResX * referenceImage.getWidth() / this.getWidth(),\n        refResY * referenceImage.getHeight() / this.getHeight(),\n        refResZ * referenceImage.getWidth() / this.getWidth(),\n      ];\n    }\n\n    throw new Error('The image does not have an affine transformation.');\n  }\n\n  /**\n   * Returns whether or not the pixels of the image depict an area (or point).\n   * @returns {Boolean} Whether the pixels are a point\n   */\n  pixelIsArea() {\n    return this.geoKeys.GTRasterTypeGeoKey === 1;\n  }\n\n  /**\n   * Returns the image bounding box as an array of 4 values: min-x, min-y,\n   * max-x and max-y. When the image has no affine transformation, then an\n   * exception is thrown.\n   * @param {boolean} [tilegrid=false] If true return extent for a tilegrid\n   *                                   without adjustment for ModelTransformation.\n   * @returns {Array<number>} The bounding box\n   */\n  getBoundingBox(tilegrid = false) {\n    const height = this.getHeight();\n    const width = this.getWidth();\n\n    if (this.fileDirectory.ModelTransformation && !tilegrid) {\n      // eslint-disable-next-line no-unused-vars\n      const [a, b, c, d, e, f, g, h] = this.fileDirectory.ModelTransformation;\n\n      const corners = [\n        [0, 0],\n        [0, height],\n        [width, 0],\n        [width, height],\n      ];\n\n      const projected = corners.map(([I, J]) => [\n        d + (a * I) + (b * J),\n        h + (e * I) + (f * J),\n      ]);\n\n      const xs = projected.map((pt) => pt[0]);\n      const ys = projected.map((pt) => pt[1]);\n\n      return [\n        Math.min(...xs),\n        Math.min(...ys),\n        Math.max(...xs),\n        Math.max(...ys),\n      ];\n    } else {\n      const origin = this.getOrigin();\n      const resolution = this.getResolution();\n\n      const x1 = origin[0];\n      const y1 = origin[1];\n\n      const x2 = x1 + (resolution[0] * width);\n      const y2 = y1 + (resolution[1] * height);\n\n      return [\n        Math.min(x1, x2),\n        Math.min(y1, y2),\n        Math.max(x1, x2),\n        Math.max(y1, y2),\n      ];\n    }\n  }\n}\n\nexport default GeoTIFFImage;\n","import { getFloat16 } from '@petamoriken/float16';\n\nexport default class DataView64 {\n  constructor(arrayBuffer) {\n    this._dataView = new DataView(arrayBuffer);\n  }\n\n  get buffer() {\n    return this._dataView.buffer;\n  }\n\n  getUint64(offset, littleEndian) {\n    const left = this.getUint32(offset, littleEndian);\n    const right = this.getUint32(offset + 4, littleEndian);\n    let combined;\n    if (littleEndian) {\n      combined = left + ((2 ** 32) * right);\n      if (!Number.isSafeInteger(combined)) {\n        throw new Error(\n          `${combined} exceeds MAX_SAFE_INTEGER. `\n          + 'Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues',\n        );\n      }\n      return combined;\n    }\n    combined = ((2 ** 32) * left) + right;\n    if (!Number.isSafeInteger(combined)) {\n      throw new Error(\n        `${combined} exceeds MAX_SAFE_INTEGER. `\n        + 'Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues',\n      );\n    }\n\n    return combined;\n  }\n\n  // adapted from https://stackoverflow.com/a/55338384/8060591\n  getInt64(offset, littleEndian) {\n    let value = 0;\n    const isNegative = (this._dataView.getUint8(offset + (littleEndian ? 7 : 0)) & 0x80) > 0;\n    let carrying = true;\n    for (let i = 0; i < 8; i++) {\n      let byte = this._dataView.getUint8(offset + (littleEndian ? i : 7 - i));\n      if (isNegative) {\n        if (carrying) {\n          if (byte !== 0x00) {\n            byte = ~(byte - 1) & 0xff;\n            carrying = false;\n          }\n        } else {\n          byte = ~byte & 0xff;\n        }\n      }\n      value += byte * (256 ** i);\n    }\n    if (isNegative) {\n      value = -value;\n    }\n    return value;\n  }\n\n  getUint8(offset, littleEndian) {\n    return this._dataView.getUint8(offset, littleEndian);\n  }\n\n  getInt8(offset, littleEndian) {\n    return this._dataView.getInt8(offset, littleEndian);\n  }\n\n  getUint16(offset, littleEndian) {\n    return this._dataView.getUint16(offset, littleEndian);\n  }\n\n  getInt16(offset, littleEndian) {\n    return this._dataView.getInt16(offset, littleEndian);\n  }\n\n  getUint32(offset, littleEndian) {\n    return this._dataView.getUint32(offset, littleEndian);\n  }\n\n  getInt32(offset, littleEndian) {\n    return this._dataView.getInt32(offset, littleEndian);\n  }\n\n  getFloat16(offset, littleEndian) {\n    return getFloat16(this._dataView, offset, littleEndian);\n  }\n\n  getFloat32(offset, littleEndian) {\n    return this._dataView.getFloat32(offset, littleEndian);\n  }\n\n  getFloat64(offset, littleEndian) {\n    return this._dataView.getFloat64(offset, littleEndian);\n  }\n}\n","export default class DataSlice {\n  constructor(arrayBuffer, sliceOffset, littleEndian, bigTiff) {\n    this._dataView = new DataView(arrayBuffer);\n    this._sliceOffset = sliceOffset;\n    this._littleEndian = littleEndian;\n    this._bigTiff = bigTiff;\n  }\n\n  get sliceOffset() {\n    return this._sliceOffset;\n  }\n\n  get sliceTop() {\n    return this._sliceOffset + this.buffer.byteLength;\n  }\n\n  get littleEndian() {\n    return this._littleEndian;\n  }\n\n  get bigTiff() {\n    return this._bigTiff;\n  }\n\n  get buffer() {\n    return this._dataView.buffer;\n  }\n\n  covers(offset, length) {\n    return this.sliceOffset <= offset && this.sliceTop >= offset + length;\n  }\n\n  readUint8(offset) {\n    return this._dataView.getUint8(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readInt8(offset) {\n    return this._dataView.getInt8(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readUint16(offset) {\n    return this._dataView.getUint16(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readInt16(offset) {\n    return this._dataView.getInt16(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readUint32(offset) {\n    return this._dataView.getUint32(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readInt32(offset) {\n    return this._dataView.getInt32(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readFloat32(offset) {\n    return this._dataView.getFloat32(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readFloat64(offset) {\n    return this._dataView.getFloat64(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readUint64(offset) {\n    const left = this.readUint32(offset);\n    const right = this.readUint32(offset + 4);\n    let combined;\n    if (this._littleEndian) {\n      combined = left + ((2 ** 32) * right);\n      if (!Number.isSafeInteger(combined)) {\n        throw new Error(\n          `${combined} exceeds MAX_SAFE_INTEGER. `\n          + 'Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues',\n        );\n      }\n      return combined;\n    }\n    combined = ((2 ** 32) * left) + right;\n    if (!Number.isSafeInteger(combined)) {\n      throw new Error(\n        `${combined} exceeds MAX_SAFE_INTEGER. `\n        + 'Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues',\n      );\n    }\n\n    return combined;\n  }\n\n  // adapted from https://stackoverflow.com/a/55338384/8060591\n  readInt64(offset) {\n    let value = 0;\n    const isNegative = (this._dataView.getUint8(offset + (this._littleEndian ? 7 : 0)) & 0x80)\n      > 0;\n    let carrying = true;\n    for (let i = 0; i < 8; i++) {\n      let byte = this._dataView.getUint8(\n        offset + (this._littleEndian ? i : 7 - i),\n      );\n      if (isNegative) {\n        if (carrying) {\n          if (byte !== 0x00) {\n            byte = ~(byte - 1) & 0xff;\n            carrying = false;\n          }\n        } else {\n          byte = ~byte & 0xff;\n        }\n      }\n      value += byte * (256 ** i);\n    }\n    if (isNegative) {\n      value = -value;\n    }\n    return value;\n  }\n\n  readOffset(offset) {\n    if (this._bigTiff) {\n      return this.readUint64(offset);\n    }\n    return this.readUint32(offset);\n  }\n}\n","import { getDecoder } from './compression/index.js';\n\nconst defaultPoolSize = typeof navigator !== 'undefined' ? (navigator.hardwareConcurrency || 2) : 2;\n\n/**\n * @module pool\n */\n\n/**\n * Pool for workers to decode chunks of the images.\n */\nclass Pool {\n  /**\n   * @constructor\n   * @param {Number} [size] The size of the pool. Defaults to the number of CPUs\n   *                      available. When this parameter is `null` or 0, then the\n   *                      decoding will be done in the main thread.\n   * @param {function(): Worker} [createWorker] A function that creates the decoder worker.\n   * Defaults to a worker with all decoders that ship with geotiff.js. The `createWorker()`\n   * function is expected to return a `Worker` compatible with Web Workers. For code that\n   * runs in Node, [web-worker](https://www.npmjs.com/package/web-worker) is a good choice.\n   *\n   * A worker that uses a custom lzw decoder would look like this `my-custom-worker.js` file:\n   * ```js\n   * import { addDecoder, getDecoder } from 'geotiff';\n   * addDecoder(5, () => import ('./my-custom-lzw').then((m) => m.default));\n   * self.addEventListener('message', async (e) => {\n   *   const { id, fileDirectory, buffer } = e.data;\n   *   const decoder = await getDecoder(fileDirectory);\n   *   const decoded = await decoder.decode(fileDirectory, buffer);\n   *   self.postMessage({ decoded, id }, [decoded]);\n   * });\n   * ```\n   * The way the above code is built into a worker by the `createWorker()` function\n   * depends on the used bundler. For most bundlers, something like this will work:\n   * ```js\n   * function createWorker() {\n   *   return new Worker(new URL('./my-custom-worker.js', import.meta.url));\n   * }\n   * ```\n   */\n  constructor(size = defaultPoolSize, createWorker) {\n    this.workers = null;\n    this._awaitingDecoder = null;\n    this.size = size;\n    this.messageId = 0;\n    if (size) {\n      this._awaitingDecoder = createWorker ? Promise.resolve(createWorker) : new Promise((resolve) => {\n        import('./worker/decoder.js').then((module) => {\n          resolve(module.create);\n        });\n      });\n      this._awaitingDecoder.then((create) => {\n        this._awaitingDecoder = null;\n        this.workers = [];\n        for (let i = 0; i < size; i++) {\n          this.workers.push({ worker: create(), idle: true });\n        }\n      });\n    }\n  }\n\n  /**\n   * Decode the given block of bytes with the set compression method.\n   * @param {ArrayBuffer} buffer the array buffer of bytes to decode.\n   * @returns {Promise<ArrayBuffer>} the decoded result as a `Promise`\n   */\n  async decode(fileDirectory, buffer) {\n    if (this._awaitingDecoder) {\n      await this._awaitingDecoder;\n    }\n    return this.size === 0\n      ? getDecoder(fileDirectory).then((decoder) => decoder.decode(fileDirectory, buffer))\n      : new Promise((resolve) => {\n        const worker = this.workers.find((candidate) => candidate.idle)\n          || this.workers[Math.floor(Math.random() * this.size)];\n        worker.idle = false;\n        const id = this.messageId++;\n        const onMessage = (e) => {\n          if (e.data.id === id) {\n            worker.idle = true;\n            resolve(e.data.decoded);\n            worker.worker.removeEventListener('message', onMessage);\n          }\n        };\n        worker.worker.addEventListener('message', onMessage);\n        worker.worker.postMessage({ fileDirectory, buffer, id }, [buffer]);\n      });\n  }\n\n  destroy() {\n    if (this.workers) {\n      this.workers.forEach((worker) => {\n        worker.worker.terminate();\n      });\n      this.workers = null;\n    }\n  }\n}\n\nexport default Pool;\n","const CRLFCRLF = '\\r\\n\\r\\n';\n\n/*\n * Shim for 'Object.fromEntries'\n */\nfunction itemsToObject(items) {\n  if (typeof Object.fromEntries !== 'undefined') {\n    return Object.fromEntries(items);\n  }\n  const obj = {};\n  for (const [key, value] of items) {\n    obj[key.toLowerCase()] = value;\n  }\n  return obj;\n}\n\n/**\n * Parse HTTP headers from a given string.\n * @param {String} text the text to parse the headers from\n * @returns {Object} the parsed headers with lowercase keys\n */\nfunction parseHeaders(text) {\n  const items = text\n    .split('\\r\\n')\n    .map((line) => {\n      const kv = line.split(':').map((str) => str.trim());\n      kv[0] = kv[0].toLowerCase();\n      return kv;\n    });\n\n  return itemsToObject(items);\n}\n\n/**\n * Parse a 'Content-Type' header value to the content-type and parameters\n * @param {String} rawContentType the raw string to parse from\n * @returns {Object} the parsed content type with the fields: type and params\n */\nexport function parseContentType(rawContentType) {\n  const [type, ...rawParams] = rawContentType.split(';').map((s) => s.trim());\n  const paramsItems = rawParams.map((param) => param.split('='));\n  return { type, params: itemsToObject(paramsItems) };\n}\n\n/**\n * Parse a 'Content-Range' header value to its start, end, and total parts\n * @param {String} rawContentRange the raw string to parse from\n * @returns {Object} the parsed parts\n */\nexport function parseContentRange(rawContentRange) {\n  let start;\n  let end;\n  let total;\n\n  if (rawContentRange) {\n    [, start, end, total] = rawContentRange.match(/bytes (\\d+)-(\\d+)\\/(\\d+)/);\n    start = parseInt(start, 10);\n    end = parseInt(end, 10);\n    total = parseInt(total, 10);\n  }\n\n  return { start, end, total };\n}\n\n/**\n * Parses a list of byteranges from the given 'multipart/byteranges' HTTP response.\n * Each item in the list has the following properties:\n * - headers: the HTTP headers\n * - data: the sliced ArrayBuffer for that specific part\n * - offset: the offset of the byterange within its originating file\n * - length: the length of the byterange\n * @param {ArrayBuffer} responseArrayBuffer the response to be parsed and split\n * @param {String} boundary the boundary string used to split the sections\n * @returns {Object[]} the parsed byteranges\n */\nexport function parseByteRanges(responseArrayBuffer, boundary) {\n  let offset = null;\n  const decoder = new TextDecoder('ascii');\n  const out = [];\n\n  const startBoundary = `--${boundary}`;\n  const endBoundary = `${startBoundary}--`;\n\n  // search for the initial boundary, may be offset by some bytes\n  // TODO: more efficient to check for `--` in bytes directly\n  for (let i = 0; i < 10; ++i) {\n    const text = decoder.decode(\n      new Uint8Array(responseArrayBuffer, i, startBoundary.length),\n    );\n    if (text === startBoundary) {\n      offset = i;\n    }\n  }\n\n  if (offset === null) {\n    throw new Error('Could not find initial boundary');\n  }\n\n  while (offset < responseArrayBuffer.byteLength) {\n    const text = decoder.decode(\n      new Uint8Array(responseArrayBuffer, offset,\n        Math.min(startBoundary.length + 1024, responseArrayBuffer.byteLength - offset),\n      ),\n    );\n\n    // break if we arrived at the end\n    if (text.length === 0 || text.startsWith(endBoundary)) {\n      break;\n    }\n\n    // assert that we are actually dealing with a byterange and are at the correct offset\n    if (!text.startsWith(startBoundary)) {\n      throw new Error('Part does not start with boundary');\n    }\n\n    // get a substring from where we read the headers\n    const innerText = text.substr(startBoundary.length + 2);\n\n    if (innerText.length === 0) {\n      break;\n    }\n\n    // find the double linebreak that denotes the end of the headers\n    const endOfHeaders = innerText.indexOf(CRLFCRLF);\n\n    // parse the headers to get the content range size\n    const headers = parseHeaders(innerText.substr(0, endOfHeaders));\n    const { start, end, total } = parseContentRange(headers['content-range']);\n\n    // calculate the length of the slice and the next offset\n    const startOfData = offset + startBoundary.length + endOfHeaders + CRLFCRLF.length;\n    const length = parseInt(end, 10) + 1 - parseInt(start, 10);\n    out.push({\n      headers,\n      data: responseArrayBuffer.slice(startOfData, startOfData + length),\n      offset: start,\n      length,\n      fileSize: total,\n    });\n\n    offset = startOfData + length + 4;\n  }\n\n  return out;\n}\n","/**\n * @typedef Slice\n * @property {number} offset\n * @property {number} length\n */\n\nexport class BaseSource {\n  /**\n   *\n   * @param {Slice[]} slices\n   * @returns {ArrayBuffer[]}\n   */\n  async fetch(slices, signal = undefined) {\n    return Promise.all(\n      slices.map((slice) => this.fetchSlice(slice, signal)),\n    );\n  }\n\n  /**\n   *\n   * @param {Slice} slice\n   * @returns {ArrayBuffer}\n   */\n  async fetchSlice(slice) {\n    throw new Error(`fetching of slice ${slice} not possible, not implemented`);\n  }\n\n  /**\n   * Returns the filesize if already determined and null otherwise\n   */\n  get fileSize() {\n    return null;\n  }\n\n  async close() {\n    // no-op by default\n  }\n}\n","export default class QuickLRU extends Map {\n\tconstructor(options = {}) {\n\t\tsuper();\n\n\t\tif (!(options.maxSize && options.maxSize > 0)) {\n\t\t\tthrow new TypeError('`maxSize` must be a number greater than 0');\n\t\t}\n\n\t\tif (typeof options.maxAge === 'number' && options.maxAge === 0) {\n\t\t\tthrow new TypeError('`maxAge` must be a number greater than 0');\n\t\t}\n\n\t\t// TODO: Use private class fields when ESLint supports them.\n\t\tthis.maxSize = options.maxSize;\n\t\tthis.maxAge = options.maxAge || Number.POSITIVE_INFINITY;\n\t\tthis.onEviction = options.onEviction;\n\t\tthis.cache = new Map();\n\t\tthis.oldCache = new Map();\n\t\tthis._size = 0;\n\t}\n\n\t// TODO: Use private class methods when targeting Node.js 16.\n\t_emitEvictions(cache) {\n\t\tif (typeof this.onEviction !== 'function') {\n\t\t\treturn;\n\t\t}\n\n\t\tfor (const [key, item] of cache) {\n\t\t\tthis.onEviction(key, item.value);\n\t\t}\n\t}\n\n\t_deleteIfExpired(key, item) {\n\t\tif (typeof item.expiry === 'number' && item.expiry <= Date.now()) {\n\t\t\tif (typeof this.onEviction === 'function') {\n\t\t\t\tthis.onEviction(key, item.value);\n\t\t\t}\n\n\t\t\treturn this.delete(key);\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t_getOrDeleteIfExpired(key, item) {\n\t\tconst deleted = this._deleteIfExpired(key, item);\n\t\tif (deleted === false) {\n\t\t\treturn item.value;\n\t\t}\n\t}\n\n\t_getItemValue(key, item) {\n\t\treturn item.expiry ? this._getOrDeleteIfExpired(key, item) : item.value;\n\t}\n\n\t_peek(key, cache) {\n\t\tconst item = cache.get(key);\n\n\t\treturn this._getItemValue(key, item);\n\t}\n\n\t_set(key, value) {\n\t\tthis.cache.set(key, value);\n\t\tthis._size++;\n\n\t\tif (this._size >= this.maxSize) {\n\t\t\tthis._size = 0;\n\t\t\tthis._emitEvictions(this.oldCache);\n\t\t\tthis.oldCache = this.cache;\n\t\t\tthis.cache = new Map();\n\t\t}\n\t}\n\n\t_moveToRecent(key, item) {\n\t\tthis.oldCache.delete(key);\n\t\tthis._set(key, item);\n\t}\n\n\t* _entriesAscending() {\n\t\tfor (const item of this.oldCache) {\n\t\t\tconst [key, value] = item;\n\t\t\tif (!this.cache.has(key)) {\n\t\t\t\tconst deleted = this._deleteIfExpired(key, value);\n\t\t\t\tif (deleted === false) {\n\t\t\t\t\tyield item;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (const item of this.cache) {\n\t\t\tconst [key, value] = item;\n\t\t\tconst deleted = this._deleteIfExpired(key, value);\n\t\t\tif (deleted === false) {\n\t\t\t\tyield item;\n\t\t\t}\n\t\t}\n\t}\n\n\tget(key) {\n\t\tif (this.cache.has(key)) {\n\t\t\tconst item = this.cache.get(key);\n\n\t\t\treturn this._getItemValue(key, item);\n\t\t}\n\n\t\tif (this.oldCache.has(key)) {\n\t\t\tconst item = this.oldCache.get(key);\n\t\t\tif (this._deleteIfExpired(key, item) === false) {\n\t\t\t\tthis._moveToRecent(key, item);\n\t\t\t\treturn item.value;\n\t\t\t}\n\t\t}\n\t}\n\n\tset(key, value, {maxAge = this.maxAge} = {}) {\n\t\tconst expiry =\n\t\t\ttypeof maxAge === 'number' && maxAge !== Number.POSITIVE_INFINITY ?\n\t\t\t\tDate.now() + maxAge :\n\t\t\t\tundefined;\n\t\tif (this.cache.has(key)) {\n\t\t\tthis.cache.set(key, {\n\t\t\t\tvalue,\n\t\t\t\texpiry\n\t\t\t});\n\t\t} else {\n\t\t\tthis._set(key, {value, expiry});\n\t\t}\n\n\t\treturn this;\n\t}\n\n\thas(key) {\n\t\tif (this.cache.has(key)) {\n\t\t\treturn !this._deleteIfExpired(key, this.cache.get(key));\n\t\t}\n\n\t\tif (this.oldCache.has(key)) {\n\t\t\treturn !this._deleteIfExpired(key, this.oldCache.get(key));\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tpeek(key) {\n\t\tif (this.cache.has(key)) {\n\t\t\treturn this._peek(key, this.cache);\n\t\t}\n\n\t\tif (this.oldCache.has(key)) {\n\t\t\treturn this._peek(key, this.oldCache);\n\t\t}\n\t}\n\n\tdelete(key) {\n\t\tconst deleted = this.cache.delete(key);\n\t\tif (deleted) {\n\t\t\tthis._size--;\n\t\t}\n\n\t\treturn this.oldCache.delete(key) || deleted;\n\t}\n\n\tclear() {\n\t\tthis.cache.clear();\n\t\tthis.oldCache.clear();\n\t\tthis._size = 0;\n\t}\n\n\tresize(newSize) {\n\t\tif (!(newSize && newSize > 0)) {\n\t\t\tthrow new TypeError('`maxSize` must be a number greater than 0');\n\t\t}\n\n\t\tconst items = [...this._entriesAscending()];\n\t\tconst removeCount = items.length - newSize;\n\t\tif (removeCount < 0) {\n\t\t\tthis.cache = new Map(items);\n\t\t\tthis.oldCache = new Map();\n\t\t\tthis._size = items.length;\n\t\t} else {\n\t\t\tif (removeCount > 0) {\n\t\t\t\tthis._emitEvictions(items.slice(0, removeCount));\n\t\t\t}\n\n\t\t\tthis.oldCache = new Map(items.slice(removeCount));\n\t\t\tthis.cache = new Map();\n\t\t\tthis._size = 0;\n\t\t}\n\n\t\tthis.maxSize = newSize;\n\t}\n\n\t* keys() {\n\t\tfor (const [key] of this) {\n\t\t\tyield key;\n\t\t}\n\t}\n\n\t* values() {\n\t\tfor (const [, value] of this) {\n\t\t\tyield value;\n\t\t}\n\t}\n\n\t* [Symbol.iterator]() {\n\t\tfor (const item of this.cache) {\n\t\t\tconst [key, value] = item;\n\t\t\tconst deleted = this._deleteIfExpired(key, value);\n\t\t\tif (deleted === false) {\n\t\t\t\tyield [key, value.value];\n\t\t\t}\n\t\t}\n\n\t\tfor (const item of this.oldCache) {\n\t\t\tconst [key, value] = item;\n\t\t\tif (!this.cache.has(key)) {\n\t\t\t\tconst deleted = this._deleteIfExpired(key, value);\n\t\t\t\tif (deleted === false) {\n\t\t\t\t\tyield [key, value.value];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t* entriesDescending() {\n\t\tlet items = [...this.cache];\n\t\tfor (let i = items.length - 1; i >= 0; --i) {\n\t\t\tconst item = items[i];\n\t\t\tconst [key, value] = item;\n\t\t\tconst deleted = this._deleteIfExpired(key, value);\n\t\t\tif (deleted === false) {\n\t\t\t\tyield [key, value.value];\n\t\t\t}\n\t\t}\n\n\t\titems = [...this.oldCache];\n\t\tfor (let i = items.length - 1; i >= 0; --i) {\n\t\t\tconst item = items[i];\n\t\t\tconst [key, value] = item;\n\t\t\tif (!this.cache.has(key)) {\n\t\t\t\tconst deleted = this._deleteIfExpired(key, value);\n\t\t\t\tif (deleted === false) {\n\t\t\t\t\tyield [key, value.value];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t* entriesAscending() {\n\t\tfor (const [key, value] of this._entriesAscending()) {\n\t\t\tyield [key, value.value];\n\t\t}\n\t}\n\n\tget size() {\n\t\tif (!this._size) {\n\t\t\treturn this.oldCache.size;\n\t\t}\n\n\t\tlet oldCacheSize = 0;\n\t\tfor (const key of this.oldCache.keys()) {\n\t\t\tif (!this.cache.has(key)) {\n\t\t\t\toldCacheSize++;\n\t\t\t}\n\t\t}\n\n\t\treturn Math.min(this._size + oldCacheSize, this.maxSize);\n\t}\n\n\tentries() {\n\t\treturn this.entriesAscending();\n\t}\n\n\tforEach(callbackFunction, thisArgument = this) {\n\t\tfor (const [key, value] of this.entriesAscending()) {\n\t\t\tcallbackFunction.call(thisArgument, value, key, this);\n\t\t}\n\t}\n\n\tget [Symbol.toStringTag]() {\n\t\treturn JSON.stringify([...this.entriesAscending()]);\n\t}\n}\n","export function assign(target, source) {\n  for (const key in source) {\n    if (source.hasOwnProperty(key)) {\n      target[key] = source[key];\n    }\n  }\n}\n\nexport function chunk(iterable, length) {\n  const results = [];\n  const lengthOfIterable = iterable.length;\n  for (let i = 0; i < lengthOfIterable; i += length) {\n    const chunked = [];\n    for (let ci = i; ci < i + length; ci++) {\n      chunked.push(iterable[ci]);\n    }\n    results.push(chunked);\n  }\n  return results;\n}\n\nexport function endsWith(string, expectedEnding) {\n  if (string.length < expectedEnding.length) {\n    return false;\n  }\n  const actualEnding = string.substr(string.length - expectedEnding.length);\n  return actualEnding === expectedEnding;\n}\n\nexport function forEach(iterable, func) {\n  const { length } = iterable;\n  for (let i = 0; i < length; i++) {\n    func(iterable[i], i);\n  }\n}\n\nexport function invert(oldObj) {\n  const newObj = {};\n  for (const key in oldObj) {\n    if (oldObj.hasOwnProperty(key)) {\n      const value = oldObj[key];\n      newObj[value] = key;\n    }\n  }\n  return newObj;\n}\n\nexport function range(n) {\n  const results = [];\n  for (let i = 0; i < n; i++) {\n    results.push(i);\n  }\n  return results;\n}\n\nexport function times(numTimes, func) {\n  const results = [];\n  for (let i = 0; i < numTimes; i++) {\n    results.push(func(i));\n  }\n  return results;\n}\n\nexport function toArray(iterable) {\n  const results = [];\n  const { length } = iterable;\n  for (let i = 0; i < length; i++) {\n    results.push(iterable[i]);\n  }\n  return results;\n}\n\nexport function toArrayRecursively(input) {\n  if (input.length) {\n    return toArray(input).map(toArrayRecursively);\n  }\n  return input;\n}\n\n// copied from https://github.com/academia-de-codigo/parse-content-range-header/blob/master/index.js\nexport function parseContentRange(headerValue) {\n  if (!headerValue) {\n    return null;\n  }\n\n  if (typeof headerValue !== 'string') {\n    throw new Error('invalid argument');\n  }\n\n  const parseInt = (number) => Number.parseInt(number, 10);\n\n  // Check for presence of unit\n  let matches = headerValue.match(/^(\\w*) /);\n  const unit = matches && matches[1];\n\n  // check for start-end/size header format\n  matches = headerValue.match(/(\\d+)-(\\d+)\\/(\\d+|\\*)/);\n  if (matches) {\n    return {\n      unit,\n      first: parseInt(matches[1]),\n      last: parseInt(matches[2]),\n      length: matches[3] === '*' ? null : parseInt(matches[3]),\n    };\n  }\n\n  // check for size header format\n  matches = headerValue.match(/(\\d+|\\*)/);\n  if (matches) {\n    return {\n      unit,\n      first: null,\n      last: null,\n      length: matches[1] === '*' ? null : parseInt(matches[1]),\n    };\n  }\n\n  return null;\n}\n\n/*\n * Promisified wrapper around 'setTimeout' to allow 'await'\n */\nexport async function wait(milliseconds) {\n  return new Promise((resolve) => setTimeout(resolve, milliseconds));\n}\n\nexport function zip(a, b) {\n  const A = Array.isArray(a) ? a : Array.from(a);\n  const B = Array.isArray(b) ? b : Array.from(b);\n  return A.map((k, i) => [k, B[i]]);\n}\n\n// Based on https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error\nexport class AbortError extends Error {\n  constructor(params) {\n    // Pass remaining arguments (including vendor specific ones) to parent constructor\n    super(params);\n\n    // Maintains proper stack trace for where our error was thrown (only available on V8)\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, AbortError);\n    }\n\n    this.name = 'AbortError';\n  }\n}\n\nexport class CustomAggregateError extends Error {\n  constructor(errors, message) {\n    super(message);\n    this.errors = errors;\n    this.message = message;\n    this.name = 'AggregateError';\n  }\n}\n\nexport const AggregateError = CustomAggregateError;\n","import QuickLRU from 'quick-lru';\nimport { BaseSource } from './basesource.js';\nimport { AbortError, AggregateError, wait, zip } from '../utils.js';\n\nclass Block {\n  /**\n   *\n   * @param {number} offset\n   * @param {number} length\n   * @param {ArrayBuffer} [data]\n   */\n  constructor(offset, length, data = null) {\n    this.offset = offset;\n    this.length = length;\n    this.data = data;\n  }\n\n  /**\n   * @returns {number} the top byte border\n   */\n  get top() {\n    return this.offset + this.length;\n  }\n}\n\nclass BlockGroup {\n  /**\n   *\n   * @param {number} offset\n   * @param {number} length\n   * @param {number[]} blockIds\n   */\n  constructor(offset, length, blockIds) {\n    this.offset = offset;\n    this.length = length;\n    this.blockIds = blockIds;\n  }\n}\n\nexport class BlockedSource extends BaseSource {\n  /**\n   *\n   * @param {BaseSource} source The underlying source that shall be blocked and cached\n   * @param {object} options\n   * @param {number} [options.blockSize]\n   * @param {number} [options.cacheSize]\n   */\n  constructor(source, { blockSize = 65536, cacheSize = 100 } = {}) {\n    super();\n    this.source = source;\n    this.blockSize = blockSize;\n\n    this.blockCache = new QuickLRU({\n      maxSize: cacheSize,\n      onEviction: (blockId, block) => {\n        this.evictedBlocks.set(blockId, block);\n      },\n    });\n\n    /** @type {Map<number, Block>} */\n    this.evictedBlocks = new Map();\n\n    // mapping blockId -> Block instance\n    this.blockRequests = new Map();\n\n    // set of blockIds missing for the current requests\n    this.blockIdsToFetch = new Set();\n\n    this.abortedBlockIds = new Set();\n  }\n\n  get fileSize() {\n    return this.source.fileSize;\n  }\n\n  /**\n   *\n   * @param {import(\"./basesource\").Slice[]} slices\n   */\n  async fetch(slices, signal) {\n    const blockRequests = [];\n    const missingBlockIds = [];\n    const allBlockIds = [];\n    this.evictedBlocks.clear();\n\n    for (const { offset, length } of slices) {\n      let top = offset + length;\n\n      const { fileSize } = this;\n      if (fileSize !== null) {\n        top = Math.min(top, fileSize);\n      }\n\n      const firstBlockOffset = Math.floor(offset / this.blockSize) * this.blockSize;\n\n      for (let current = firstBlockOffset; current < top; current += this.blockSize) {\n        const blockId = Math.floor(current / this.blockSize);\n        if (!this.blockCache.has(blockId) && !this.blockRequests.has(blockId)) {\n          this.blockIdsToFetch.add(blockId);\n          missingBlockIds.push(blockId);\n        }\n        if (this.blockRequests.has(blockId)) {\n          blockRequests.push(this.blockRequests.get(blockId));\n        }\n        allBlockIds.push(blockId);\n      }\n    }\n\n    // allow additional block requests to accumulate\n    await wait();\n    this.fetchBlocks(signal);\n\n    // Gather all of the new requests that this fetch call is contributing to `fetch`.\n    const missingRequests = [];\n    for (const blockId of missingBlockIds) {\n      // The requested missing block could already be in the cache\n      // instead of having its request still be outstanding.\n      if (this.blockRequests.has(blockId)) {\n        missingRequests.push(this.blockRequests.get(blockId));\n      }\n    }\n\n    // Actually await all pending requests that are needed for this `fetch`.\n    await Promise.allSettled(blockRequests);\n    await Promise.allSettled(missingRequests);\n\n    // Perform retries if a block was interrupted by a previous signal\n    const abortedBlockRequests = [];\n    const abortedBlockIds = allBlockIds\n      .filter((id) => this.abortedBlockIds.has(id) || !this.blockCache.has(id));\n    abortedBlockIds.forEach((id) => this.blockIdsToFetch.add(id));\n    // start the retry of some blocks if required\n    if (abortedBlockIds.length > 0 && signal && !signal.aborted) {\n      this.fetchBlocks(null);\n      for (const blockId of abortedBlockIds) {\n        const block = this.blockRequests.get(blockId);\n        if (!block) {\n          throw new Error(`Block ${blockId} is not in the block requests`);\n        }\n        abortedBlockRequests.push(block);\n      }\n      await Promise.allSettled(abortedBlockRequests);\n    }\n\n    // throw an  abort error\n    if (signal && signal.aborted) {\n      throw new AbortError('Request was aborted');\n    }\n\n    const blocks = allBlockIds.map((id) => this.blockCache.get(id) || this.evictedBlocks.get(id));\n    const failedBlocks = blocks.filter((i) => !i);\n    if (failedBlocks.length) {\n      throw new AggregateError(failedBlocks, 'Request failed');\n    }\n\n    // create a final Map, with all required blocks for this request to satisfy\n    const requiredBlocks = new Map(zip(allBlockIds, blocks));\n\n    // TODO: satisfy each slice\n    return this.readSliceData(slices, requiredBlocks);\n  }\n\n  /**\n   *\n   * @param {AbortSignal} signal\n   */\n  fetchBlocks(signal) {\n    // check if we still need to\n    if (this.blockIdsToFetch.size > 0) {\n      const groups = this.groupBlocks(this.blockIdsToFetch);\n\n      // start requesting slices of data\n      const groupRequests = this.source.fetch(groups, signal);\n\n      for (let groupIndex = 0; groupIndex < groups.length; ++groupIndex) {\n        const group = groups[groupIndex];\n\n        for (const blockId of group.blockIds) {\n          // make an async IIFE for each block\n          this.blockRequests.set(blockId, (async () => {\n            try {\n              const response = (await groupRequests)[groupIndex];\n              const blockOffset = blockId * this.blockSize;\n              const o = blockOffset - response.offset;\n              const t = Math.min(o + this.blockSize, response.data.byteLength);\n              const data = response.data.slice(o, t);\n              const block = new Block(\n                blockOffset,\n                data.byteLength,\n                data,\n                blockId,\n              );\n              this.blockCache.set(blockId, block);\n              this.abortedBlockIds.delete(blockId);\n            } catch (err) {\n              if (err.name === 'AbortError') {\n                // store the signal here, we need it to determine later if an\n                // error was caused by this signal\n                err.signal = signal;\n                this.blockCache.delete(blockId);\n                this.abortedBlockIds.add(blockId);\n              } else {\n                throw err;\n              }\n            } finally {\n              this.blockRequests.delete(blockId);\n            }\n          })());\n        }\n      }\n      this.blockIdsToFetch.clear();\n    }\n  }\n\n  /**\n   *\n   * @param {Set} blockIds\n   * @returns {BlockGroup[]}\n   */\n  groupBlocks(blockIds) {\n    const sortedBlockIds = Array.from(blockIds).sort((a, b) => a - b);\n    if (sortedBlockIds.length === 0) {\n      return [];\n    }\n    let current = [];\n    let lastBlockId = null;\n    const groups = [];\n\n    for (const blockId of sortedBlockIds) {\n      if (lastBlockId === null || lastBlockId + 1 === blockId) {\n        current.push(blockId);\n        lastBlockId = blockId;\n      } else {\n        groups.push(new BlockGroup(\n          current[0] * this.blockSize,\n          current.length * this.blockSize,\n          current,\n        ));\n        current = [blockId];\n        lastBlockId = blockId;\n      }\n    }\n\n    groups.push(new BlockGroup(\n      current[0] * this.blockSize,\n      current.length * this.blockSize,\n      current,\n    ));\n\n    return groups;\n  }\n\n  /**\n   *\n   * @param {import(\"./basesource\").Slice[]} slices\n   * @param {Map} blocks\n   */\n  readSliceData(slices, blocks) {\n    return slices.map((slice) => {\n      let top = slice.offset + slice.length;\n      if (this.fileSize !== null) {\n        top = Math.min(this.fileSize, top);\n      }\n      const blockIdLow = Math.floor(slice.offset / this.blockSize);\n      const blockIdHigh = Math.floor(top / this.blockSize);\n      const sliceData = new ArrayBuffer(slice.length);\n      const sliceView = new Uint8Array(sliceData);\n\n      for (let blockId = blockIdLow; blockId <= blockIdHigh; ++blockId) {\n        const block = blocks.get(blockId);\n        const delta = block.offset - slice.offset;\n        const topDelta = block.top - top;\n        let blockInnerOffset = 0;\n        let rangeInnerOffset = 0;\n        let usedBlockLength;\n\n        if (delta < 0) {\n          blockInnerOffset = -delta;\n        } else if (delta > 0) {\n          rangeInnerOffset = delta;\n        }\n\n        if (topDelta < 0) {\n          usedBlockLength = block.length - blockInnerOffset;\n        } else {\n          usedBlockLength = top - block.offset - blockInnerOffset;\n        }\n\n        const blockView = new Uint8Array(block.data, blockInnerOffset, usedBlockLength);\n        sliceView.set(blockView, rangeInnerOffset);\n      }\n\n      return sliceData;\n    });\n  }\n}\n","export class BaseResponse {\n  /**\n   * Returns whether the response has an ok'ish status code\n   */\n  get ok() {\n    return this.status >= 200 && this.status <= 299;\n  }\n\n  /**\n   * Returns the status code of the response\n   */\n  get status() {\n    throw new Error('not implemented');\n  }\n\n  /**\n   * Returns the value of the specified header\n   * @param {string} headerName the header name\n   * @returns {string} the header value\n   */\n  getHeader(headerName) { // eslint-disable-line no-unused-vars\n    throw new Error('not implemented');\n  }\n\n  /**\n   * @returns {ArrayBuffer} the response data of the request\n   */\n  async getData() {\n    throw new Error('not implemented');\n  }\n}\n\nexport class BaseClient {\n  constructor(url) {\n    this.url = url;\n  }\n\n  /**\n   * Send a request with the options\n   * @param {{headers: HeadersInit, signal: AbortSignal}} [options={}]\n   * @returns {Promise<BaseResponse>}\n   */\n  async request({ headers, signal } = {}) { // eslint-disable-line no-unused-vars\n    throw new Error('request is not implemented');\n  }\n}\n","import { BaseClient, BaseResponse } from './base.js';\n\nclass FetchResponse extends BaseResponse {\n  /**\n   * BaseResponse facade for fetch API Response\n   * @param {Response} response\n   */\n  constructor(response) {\n    super();\n    this.response = response;\n  }\n\n  get status() {\n    return this.response.status;\n  }\n\n  getHeader(name) {\n    return this.response.headers.get(name);\n  }\n\n  async getData() {\n    const data = this.response.arrayBuffer\n      ? await this.response.arrayBuffer()\n      : (await this.response.buffer()).buffer;\n    return data;\n  }\n}\n\nexport class FetchClient extends BaseClient {\n  constructor(url, credentials) {\n    super(url);\n    this.credentials = credentials;\n  }\n\n  /**\n   * @param {{headers: HeadersInit, signal: AbortSignal}} [options={}]\n   * @returns {Promise<FetchResponse>}\n   */\n  async request({ headers, signal } = {}) {\n    const response = await fetch(this.url, {\n      headers, credentials: this.credentials, signal,\n    });\n    return new FetchResponse(response);\n  }\n}\n","import { BaseClient, BaseResponse } from './base.js';\nimport { AbortError } from '../../utils.js';\n\nclass XHRResponse extends BaseResponse {\n  /**\n   * BaseResponse facade for XMLHttpRequest\n   * @param {XMLHttpRequest} xhr\n   * @param {ArrayBuffer} data\n   */\n  constructor(xhr, data) {\n    super();\n    this.xhr = xhr;\n    this.data = data;\n  }\n\n  get status() {\n    return this.xhr.status;\n  }\n\n  getHeader(name) {\n    return this.xhr.getResponseHeader(name);\n  }\n\n  async getData() {\n    return this.data;\n  }\n}\n\nexport class XHRClient extends BaseClient {\n  constructRequest(headers, signal) {\n    return new Promise((resolve, reject) => {\n      const xhr = new XMLHttpRequest();\n      xhr.open('GET', this.url);\n      xhr.responseType = 'arraybuffer';\n      for (const [key, value] of Object.entries(headers)) {\n        xhr.setRequestHeader(key, value);\n      }\n\n      // hook signals\n      xhr.onload = () => {\n        const data = xhr.response;\n        resolve(new XHRResponse(xhr, data));\n      };\n      xhr.onerror = reject;\n      xhr.onabort = () => reject(new AbortError('Request aborted'));\n      xhr.send();\n\n      if (signal) {\n        if (signal.aborted) {\n          xhr.abort();\n        }\n        signal.addEventListener('abort', () => xhr.abort());\n      }\n    });\n  }\n\n  async request({ headers, signal } = {}) {\n    const response = await this.constructRequest(headers, signal);\n    return response;\n  }\n}\n","export default {}","import http from 'http';\nimport https from 'https';\nimport urlMod from 'url';\n\nimport { BaseClient, BaseResponse } from './base.js';\nimport { AbortError } from '../../utils.js';\n\nclass HttpResponse extends BaseResponse {\n  /**\n   * BaseResponse facade for node HTTP/HTTPS API Response\n   * @param {http.ServerResponse} response\n   */\n  constructor(response, dataPromise) {\n    super();\n    this.response = response;\n    this.dataPromise = dataPromise;\n  }\n\n  get status() {\n    return this.response.statusCode;\n  }\n\n  getHeader(name) {\n    return this.response.headers[name];\n  }\n\n  async getData() {\n    const data = await this.dataPromise;\n    return data;\n  }\n}\n\nexport class HttpClient extends BaseClient {\n  constructor(url) {\n    super(url);\n    this.parsedUrl = urlMod.parse(this.url);\n    this.httpApi = (this.parsedUrl.protocol === 'http:' ? http : https);\n  }\n\n  constructRequest(headers, signal) {\n    return new Promise((resolve, reject) => {\n      const request = this.httpApi.get(\n        {\n          ...this.parsedUrl,\n          headers,\n        },\n        (response) => {\n          const dataPromise = new Promise((resolveData) => {\n            const chunks = [];\n\n            // collect chunks\n            response.on('data', (chunk) => {\n              chunks.push(chunk);\n            });\n\n            // concatenate all chunks and resolve the promise with the resulting buffer\n            response.on('end', () => {\n              const data = Buffer.concat(chunks).buffer;\n              resolveData(data);\n            });\n            response.on('error', reject);\n          });\n          resolve(new HttpResponse(response, dataPromise));\n        },\n      );\n      request.on('error', reject);\n\n      if (signal) {\n        if (signal.aborted) {\n          request.destroy(new AbortError('Request aborted'));\n        }\n        signal.addEventListener('abort', () => request.destroy(new AbortError('Request aborted')));\n      }\n    });\n  }\n\n  async request({ headers, signal } = {}) {\n    const response = await this.constructRequest(headers, signal);\n    return response;\n  }\n}\n","import { parseByteRanges, parseContentRange, parseContentType } from './httputils.js';\nimport { BaseSource } from './basesource.js';\nimport { BlockedSource } from './blockedsource.js';\n\nimport { FetchClient } from './client/fetch.js';\nimport { XHRClient } from './client/xhr.js';\nimport { HttpClient } from './client/http.js';\n\nclass RemoteSource extends BaseSource {\n  /**\n   *\n   * @param {BaseClient} client\n   * @param {object} headers\n   * @param {numbers} maxRanges\n   * @param {boolean} allowFullFile\n   */\n  constructor(client, headers, maxRanges, allowFullFile) {\n    super();\n    this.client = client;\n    this.headers = headers;\n    this.maxRanges = maxRanges;\n    this.allowFullFile = allowFullFile;\n    this._fileSize = null;\n  }\n\n  /**\n   *\n   * @param {Slice[]} slices\n   */\n  async fetch(slices, signal) {\n    // if we allow multi-ranges, split the incoming request into that many sub-requests\n    // and join them afterwards\n    if (this.maxRanges >= slices.length) {\n      return this.fetchSlices(slices, signal);\n    } else if (this.maxRanges > 0 && slices.length > 1) {\n      // TODO: split into multiple multi-range requests\n\n      // const subSlicesRequests = [];\n      // for (let i = 0; i < slices.length; i += this.maxRanges) {\n      //   subSlicesRequests.push(\n      //     this.fetchSlices(slices.slice(i, i + this.maxRanges), signal),\n      //   );\n      // }\n      // return (await Promise.all(subSlicesRequests)).flat();\n    }\n\n    // otherwise make a single request for each slice\n    return Promise.all(\n      slices.map((slice) => this.fetchSlice(slice, signal)),\n    );\n  }\n\n  async fetchSlices(slices, signal) {\n    const response = await this.client.request({\n      headers: {\n        ...this.headers,\n        Range: `bytes=${slices\n          .map(({ offset, length }) => `${offset}-${offset + length}`)\n          .join(',')\n        }`,\n      },\n      signal,\n    });\n\n    if (!response.ok) {\n      throw new Error('Error fetching data.');\n    } else if (response.status === 206) {\n      const { type, params } = parseContentType(response.getHeader('content-type'));\n      if (type === 'multipart/byteranges') {\n        const byteRanges = parseByteRanges(await response.getData(), params.boundary);\n        this._fileSize = byteRanges[0].fileSize || null;\n        return byteRanges;\n      }\n\n      const data = await response.getData();\n\n      const { start, end, total } = parseContentRange(response.getHeader('content-range'));\n      this._fileSize = total || null;\n      const first = [{\n        data,\n        offset: start,\n        length: end - start,\n      }];\n\n      if (slices.length > 1) {\n        // we requested more than one slice, but got only the first\n        // unfortunately, some HTTP Servers don't support multi-ranges\n        // and return only the first\n\n        // get the rest of the slices and fetch them iteratively\n        const others = await Promise.all(slices.slice(1).map((slice) => this.fetchSlice(slice, signal)));\n        return first.concat(others);\n      }\n      return first;\n    } else {\n      if (!this.allowFullFile) {\n        throw new Error('Server responded with full file');\n      }\n      const data = await response.getData();\n      this._fileSize = data.byteLength;\n      return [{\n        data,\n        offset: 0,\n        length: data.byteLength,\n      }];\n    }\n  }\n\n  async fetchSlice(slice, signal) {\n    const { offset, length } = slice;\n    const response = await this.client.request({\n      headers: {\n        ...this.headers,\n        Range: `bytes=${offset}-${offset + length}`,\n      },\n      signal,\n    });\n\n    // check the response was okay and if the server actually understands range requests\n    if (!response.ok) {\n      throw new Error('Error fetching data.');\n    } else if (response.status === 206) {\n      const data = await response.getData();\n\n      const { total } = parseContentRange(response.getHeader('content-range'));\n      this._fileSize = total || null;\n      return {\n        data,\n        offset,\n        length,\n      };\n    } else {\n      if (!this.allowFullFile) {\n        throw new Error('Server responded with full file');\n      }\n\n      const data = await response.getData();\n\n      this._fileSize = data.byteLength;\n      return {\n        data,\n        offset: 0,\n        length: data.byteLength,\n      };\n    }\n  }\n\n  get fileSize() {\n    return this._fileSize;\n  }\n}\n\nfunction maybeWrapInBlockedSource(source, { blockSize, cacheSize }) {\n  if (blockSize === null) {\n    return source;\n  }\n  return new BlockedSource(source, { blockSize, cacheSize });\n}\n\nexport function makeFetchSource(url, { headers = {}, credentials, maxRanges = 0, allowFullFile = false, ...blockOptions } = {}) {\n  const client = new FetchClient(url, credentials);\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\n\nexport function makeXHRSource(url, { headers = {}, maxRanges = 0, allowFullFile = false, ...blockOptions } = {}) {\n  const client = new XHRClient(url);\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\n\nexport function makeHttpSource(url, { headers = {}, maxRanges = 0, allowFullFile = false, ...blockOptions } = {}) {\n  const client = new HttpClient(url);\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\n\nexport function makeCustomSource(client, { headers = {}, maxRanges = 0, allowFullFile = false, ...blockOptions } = {}) {\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\n\n/**\n *\n * @param {string} url\n * @param {object} options\n */\nexport function makeRemoteSource(url, { forceXHR = false, ...clientOptions } = {}) {\n  if (typeof fetch === 'function' && !forceXHR) {\n    return makeFetchSource(url, clientOptions);\n  }\n  if (typeof XMLHttpRequest !== 'undefined') {\n    return makeXHRSource(url, clientOptions);\n  }\n  return makeHttpSource(url, clientOptions);\n}\n","import { BaseSource } from './basesource.js';\nimport { AbortError } from '../utils.js';\n\nclass ArrayBufferSource extends BaseSource {\n  constructor(arrayBuffer) {\n    super();\n    this.arrayBuffer = arrayBuffer;\n  }\n\n  fetchSlice(slice, signal) {\n    if (signal && signal.aborted) {\n      throw new AbortError('Request aborted');\n    }\n    return this.arrayBuffer.slice(slice.offset, slice.offset + slice.length);\n  }\n}\n\nexport function makeBufferSource(arrayBuffer) {\n  return new ArrayBufferSource(arrayBuffer);\n}\n","import { BaseSource } from './basesource.js';\n\nclass FileReaderSource extends BaseSource {\n  constructor(file) {\n    super();\n    this.file = file;\n  }\n\n  async fetchSlice(slice, signal) {\n    return new Promise((resolve, reject) => {\n      const blob = this.file.slice(slice.offset, slice.offset + slice.length);\n      const reader = new FileReader();\n      reader.onload = (event) => resolve(event.target.result);\n      reader.onerror = reject;\n      reader.onabort = reject;\n      reader.readAsArrayBuffer(blob);\n\n      if (signal) {\n        signal.addEventListener('abort', () => reader.abort());\n      }\n    });\n  }\n}\n\n/**\n * Create a new source from a given file/blob.\n * @param {Blob} file The file or blob to read from.\n * @returns The constructed source\n */\nexport function makeFileReaderSource(file) {\n  return new FileReaderSource(file);\n}\n","import fs from 'fs';\nimport { BaseSource } from './basesource.js';\n\nfunction closeAsync(fd) {\n  return new Promise((resolve, reject) => {\n    fs.close(fd, (err) => {\n      if (err) {\n        reject(err);\n      } else {\n        resolve();\n      }\n    });\n  });\n}\n\nfunction openAsync(path, flags, mode = undefined) {\n  return new Promise((resolve, reject) => {\n    fs.open(path, flags, mode, (err, fd) => {\n      if (err) {\n        reject(err);\n      } else {\n        resolve(fd);\n      }\n    });\n  });\n}\n\nfunction readAsync(...args) {\n  return new Promise((resolve, reject) => {\n    fs.read(...args, (err, bytesRead, buffer) => {\n      if (err) {\n        reject(err);\n      } else {\n        resolve({ bytesRead, buffer });\n      }\n    });\n  });\n}\n\nclass FileSource extends BaseSource {\n  constructor(path) {\n    super();\n    this.path = path;\n    this.openRequest = openAsync(path, 'r');\n  }\n\n  async fetchSlice(slice) {\n    // TODO: use `signal`\n    const fd = await this.openRequest;\n    const { buffer } = await readAsync(\n      fd,\n      Buffer.alloc(slice.length),\n      0,\n      slice.length,\n      slice.offset,\n    );\n    return buffer.buffer;\n  }\n\n  async close() {\n    const fd = await this.openRequest;\n    await closeAsync(fd);\n  }\n}\n\nexport function makeFileSource(path) {\n  return new FileSource(path);\n}\n","/*\n  Some parts of this file are based on UTIF.js,\n  which was released under the MIT License.\n  You can view that here:\n  https://github.com/photopea/UTIF.js/blob/master/LICENSE\n*/\nimport { fieldTagNames, fieldTagTypes, fieldTypeNames, geoKeyNames } from './globals.js';\nimport { assign, endsWith, forEach, invert, times } from './utils.js';\n\nconst tagName2Code = invert(fieldTagNames);\nconst geoKeyName2Code = invert(geoKeyNames);\nconst name2code = {};\nassign(name2code, tagName2Code);\nassign(name2code, geoKeyName2Code);\nconst typeName2byte = invert(fieldTypeNames);\n\n// config variables\nconst numBytesInIfd = 1000;\n\nconst _binBE = {\n  nextZero: (data, o) => {\n    let oincr = o;\n    while (data[oincr] !== 0) {\n      oincr++;\n    }\n    return oincr;\n  },\n  readUshort: (buff, p) => {\n    return (buff[p] << 8) | buff[p + 1];\n  },\n  readShort: (buff, p) => {\n    const a = _binBE.ui8;\n    a[0] = buff[p + 1];\n    a[1] = buff[p + 0];\n    return _binBE.i16[0];\n  },\n  readInt: (buff, p) => {\n    const a = _binBE.ui8;\n    a[0] = buff[p + 3];\n    a[1] = buff[p + 2];\n    a[2] = buff[p + 1];\n    a[3] = buff[p + 0];\n    return _binBE.i32[0];\n  },\n  readUint: (buff, p) => {\n    const a = _binBE.ui8;\n    a[0] = buff[p + 3];\n    a[1] = buff[p + 2];\n    a[2] = buff[p + 1];\n    a[3] = buff[p + 0];\n    return _binBE.ui32[0];\n  },\n  readASCII: (buff, p, l) => {\n    return l.map((i) => String.fromCharCode(buff[p + i])).join('');\n  },\n  readFloat: (buff, p) => {\n    const a = _binBE.ui8;\n    times(4, (i) => {\n      a[i] = buff[p + 3 - i];\n    });\n    return _binBE.fl32[0];\n  },\n  readDouble: (buff, p) => {\n    const a = _binBE.ui8;\n    times(8, (i) => {\n      a[i] = buff[p + 7 - i];\n    });\n    return _binBE.fl64[0];\n  },\n  writeUshort: (buff, p, n) => {\n    buff[p] = (n >> 8) & 255;\n    buff[p + 1] = n & 255;\n  },\n  writeUint: (buff, p, n) => {\n    buff[p] = (n >> 24) & 255;\n    buff[p + 1] = (n >> 16) & 255;\n    buff[p + 2] = (n >> 8) & 255;\n    buff[p + 3] = (n >> 0) & 255;\n  },\n  writeASCII: (buff, p, s) => {\n    times(s.length, (i) => {\n      buff[p + i] = s.charCodeAt(i);\n    });\n  },\n  ui8: new Uint8Array(8),\n};\n\n_binBE.fl64 = new Float64Array(_binBE.ui8.buffer);\n\n_binBE.writeDouble = (buff, p, n) => {\n  _binBE.fl64[0] = n;\n  times(8, (i) => {\n    buff[p + i] = _binBE.ui8[7 - i];\n  });\n};\n\nconst _writeIFD = (bin, data, _offset, ifd) => {\n  let offset = _offset;\n\n  const keys = Object.keys(ifd).filter((key) => {\n    return key !== undefined && key !== null && key !== 'undefined';\n  });\n\n  bin.writeUshort(data, offset, keys.length);\n  offset += 2;\n\n  let eoff = offset + (12 * keys.length) + 4;\n\n  for (const key of keys) {\n    let tag = null;\n    if (typeof key === 'number') {\n      tag = key;\n    } else if (typeof key === 'string') {\n      tag = parseInt(key, 10);\n    }\n\n    const typeName = fieldTagTypes[tag];\n    const typeNum = typeName2byte[typeName];\n\n    if (typeName == null || typeName === undefined || typeof typeName === 'undefined') {\n      throw new Error(`unknown type of tag: ${tag}`);\n    }\n\n    let val = ifd[key];\n\n    if (val === undefined) {\n      throw new Error(`failed to get value for key ${key}`);\n    }\n\n    // ASCIIZ format with trailing 0 character\n    // http://www.fileformat.info/format/tiff/corion.htm\n    // https://stackoverflow.com/questions/7783044/whats-the-difference-between-asciiz-vs-ascii\n    if (typeName === 'ASCII' && typeof val === 'string' && endsWith(val, '\\u0000') === false) {\n      val += '\\u0000';\n    }\n\n    const num = val.length;\n\n    bin.writeUshort(data, offset, tag);\n    offset += 2;\n\n    bin.writeUshort(data, offset, typeNum);\n    offset += 2;\n\n    bin.writeUint(data, offset, num);\n    offset += 4;\n\n    let dlen = [-1, 1, 1, 2, 4, 8, 0, 0, 0, 0, 0, 0, 8][typeNum] * num;\n    let toff = offset;\n\n    if (dlen > 4) {\n      bin.writeUint(data, offset, eoff);\n      toff = eoff;\n    }\n\n    if (typeName === 'ASCII') {\n      bin.writeASCII(data, toff, val);\n    } else if (typeName === 'SHORT') {\n      times(num, (i) => {\n        bin.writeUshort(data, toff + (2 * i), val[i]);\n      });\n    } else if (typeName === 'LONG') {\n      times(num, (i) => {\n        bin.writeUint(data, toff + (4 * i), val[i]);\n      });\n    } else if (typeName === 'RATIONAL') {\n      times(num, (i) => {\n        bin.writeUint(data, toff + (8 * i), Math.round(val[i] * 10000));\n        bin.writeUint(data, toff + (8 * i) + 4, 10000);\n      });\n    } else if (typeName === 'DOUBLE') {\n      times(num, (i) => {\n        bin.writeDouble(data, toff + (8 * i), val[i]);\n      });\n    }\n\n    if (dlen > 4) {\n      dlen += (dlen & 1);\n      eoff += dlen;\n    }\n\n    offset += 4;\n  }\n\n  return [offset, eoff];\n};\n\nconst encodeIfds = (ifds) => {\n  const data = new Uint8Array(numBytesInIfd);\n  let offset = 4;\n  const bin = _binBE;\n\n  // set big-endian byte-order\n  // https://en.wikipedia.org/wiki/TIFF#Byte_order\n  data[0] = 77;\n  data[1] = 77;\n\n  // set format-version number\n  // https://en.wikipedia.org/wiki/TIFF#Byte_order\n  data[3] = 42;\n\n  let ifdo = 8;\n\n  bin.writeUint(data, offset, ifdo);\n\n  offset += 4;\n\n  ifds.forEach((ifd, i) => {\n    const noffs = _writeIFD(bin, data, ifdo, ifd);\n    ifdo = noffs[1];\n    if (i < ifds.length - 1) {\n      bin.writeUint(data, noffs[0], ifdo);\n    }\n  });\n\n  if (data.slice) {\n    return data.slice(0, ifdo).buffer;\n  }\n\n  // node hasn't implemented slice on Uint8Array yet\n  const result = new Uint8Array(ifdo);\n  for (let i = 0; i < ifdo; i++) {\n    result[i] = data[i];\n  }\n  return result.buffer;\n};\n\nconst encodeImage = (values, width, height, metadata) => {\n  if (height === undefined || height === null) {\n    throw new Error(`you passed into encodeImage a width of type ${height}`);\n  }\n\n  if (width === undefined || width === null) {\n    throw new Error(`you passed into encodeImage a width of type ${width}`);\n  }\n\n  const ifd = {\n    256: [width], // ImageWidth\n    257: [height], // ImageLength\n    273: [numBytesInIfd], // strips offset\n    278: [height], // RowsPerStrip\n    305: 'geotiff.js', // no array for ASCII(Z)\n  };\n\n  if (metadata) {\n    for (const i in metadata) {\n      if (metadata.hasOwnProperty(i)) {\n        ifd[i] = metadata[i];\n      }\n    }\n  }\n\n  const prfx = new Uint8Array(encodeIfds([ifd]));\n\n  const img = new Uint8Array(values);\n\n  const samplesPerPixel = ifd[277];\n\n  const data = new Uint8Array(numBytesInIfd + (width * height * samplesPerPixel));\n  times(prfx.length, (i) => {\n    data[i] = prfx[i];\n  });\n  forEach(img, (value, i) => {\n    data[numBytesInIfd + i] = value;\n  });\n\n  return data.buffer;\n};\n\nconst convertToTids = (input) => {\n  const result = {};\n  for (const key in input) {\n    if (key !== 'StripOffsets') {\n      if (!name2code[key]) {\n        console.error(key, 'not in name2code:', Object.keys(name2code));\n      }\n      result[name2code[key]] = input[key];\n    }\n  }\n  return result;\n};\n\nconst toArray = (input) => {\n  if (Array.isArray(input)) {\n    return input;\n  }\n  return [input];\n};\n\nconst metadataDefaults = [\n  ['Compression', 1], // no compression\n  ['PlanarConfiguration', 1],\n  ['ExtraSamples', 0],\n];\n\nexport function writeGeotiff(data, metadata) {\n  const isFlattened = typeof data[0] === 'number';\n\n  let height;\n  let numBands;\n  let width;\n  let flattenedValues;\n\n  if (isFlattened) {\n    height = metadata.height || metadata.ImageLength;\n    width = metadata.width || metadata.ImageWidth;\n    numBands = data.length / (height * width);\n    flattenedValues = data;\n  } else {\n    numBands = data.length;\n    height = data[0].length;\n    width = data[0][0].length;\n    flattenedValues = [];\n    times(height, (rowIndex) => {\n      times(width, (columnIndex) => {\n        times(numBands, (bandIndex) => {\n          flattenedValues.push(data[bandIndex][rowIndex][columnIndex]);\n        });\n      });\n    });\n  }\n\n  metadata.ImageLength = height;\n  delete metadata.height;\n  metadata.ImageWidth = width;\n  delete metadata.width;\n\n  // consult https://www.loc.gov/preservation/digital/formats/content/tiff_tags.shtml\n\n  if (!metadata.BitsPerSample) {\n    metadata.BitsPerSample = times(numBands, () => 8);\n  }\n\n  metadataDefaults.forEach((tag) => {\n    const key = tag[0];\n    if (!metadata[key]) {\n      const value = tag[1];\n      metadata[key] = value;\n    }\n  });\n\n  // The color space of the image data.\n  // 1=black is zero and 2=RGB.\n  if (!metadata.PhotometricInterpretation) {\n    metadata.PhotometricInterpretation = metadata.BitsPerSample.length === 3 ? 2 : 1;\n  }\n\n  // The number of components per pixel.\n  if (!metadata.SamplesPerPixel) {\n    metadata.SamplesPerPixel = [numBands];\n  }\n\n  if (!metadata.StripByteCounts) {\n    // we are only writing one strip\n    metadata.StripByteCounts = [numBands * height * width];\n  }\n\n  if (!metadata.ModelPixelScale) {\n    // assumes raster takes up exactly the whole globe\n    metadata.ModelPixelScale = [360 / width, 180 / height, 0];\n  }\n\n  if (!metadata.SampleFormat) {\n    metadata.SampleFormat = times(numBands, () => 1);\n  }\n\n  // if didn't pass in projection information, assume the popular 4326 \"geographic projection\"\n  if (!metadata.hasOwnProperty('GeographicTypeGeoKey') && !metadata.hasOwnProperty('ProjectedCSTypeGeoKey')) {\n    metadata.GeographicTypeGeoKey = 4326;\n    metadata.ModelTiepoint = [0, 0, 0, -180, 90, 0]; // raster fits whole globe\n    metadata.GeogCitationGeoKey = 'WGS 84';\n    metadata.GTModelTypeGeoKey = 2;\n  }\n\n  const geoKeys = Object.keys(metadata)\n    .filter((key) => endsWith(key, 'GeoKey'))\n    .sort((a, b) => name2code[a] - name2code[b]);\n\n  if (!metadata.GeoAsciiParams) {\n    let geoAsciiParams = '';\n    geoKeys.forEach((name) => {\n      const code = Number(name2code[name]);\n      const tagType = fieldTagTypes[code];\n      if (tagType === 'ASCII') {\n        geoAsciiParams += `${metadata[name].toString()}\\u0000`;\n      }\n    });\n    if (geoAsciiParams.length > 0) {\n      metadata.GeoAsciiParams = geoAsciiParams;\n    }\n  }\n\n  if (!metadata.GeoKeyDirectory) {\n    const NumberOfKeys = geoKeys.length;\n\n    const GeoKeyDirectory = [1, 1, 0, NumberOfKeys];\n    geoKeys.forEach((geoKey) => {\n      const KeyID = Number(name2code[geoKey]);\n      GeoKeyDirectory.push(KeyID);\n\n      let Count;\n      let TIFFTagLocation;\n      let valueOffset;\n      if (fieldTagTypes[KeyID] === 'SHORT') {\n        Count = 1;\n        TIFFTagLocation = 0;\n        valueOffset = metadata[geoKey];\n      } else if (geoKey === 'GeogCitationGeoKey') {\n        Count = metadata.GeoAsciiParams.length;\n        TIFFTagLocation = Number(name2code.GeoAsciiParams);\n        valueOffset = 0;\n      } else {\n        console.log(`[geotiff.js] couldn't get TIFFTagLocation for ${geoKey}`);\n      }\n      GeoKeyDirectory.push(TIFFTagLocation);\n      GeoKeyDirectory.push(Count);\n      GeoKeyDirectory.push(valueOffset);\n    });\n    metadata.GeoKeyDirectory = GeoKeyDirectory;\n  }\n\n  // delete GeoKeys from metadata, because stored in GeoKeyDirectory tag\n  for (const geoKey of geoKeys) {\n    if (metadata.hasOwnProperty(geoKey)) {\n      delete metadata[geoKey];\n    }\n  }\n\n  [\n    'Compression',\n    'ExtraSamples',\n    'GeographicTypeGeoKey',\n    'GTModelTypeGeoKey',\n    'GTRasterTypeGeoKey',\n    'ImageLength', // synonym of ImageHeight\n    'ImageWidth',\n    'Orientation',\n    'PhotometricInterpretation',\n    'ProjectedCSTypeGeoKey',\n    'PlanarConfiguration',\n    'ResolutionUnit',\n    'SamplesPerPixel',\n    'XPosition',\n    'YPosition',\n    'RowsPerStrip',\n  ].forEach((name) => {\n    if (metadata[name]) {\n      metadata[name] = toArray(metadata[name]);\n    }\n  });\n\n  const encodedMetadata = convertToTids(metadata);\n\n  const outputImage = encodeImage(flattenedValues, width, height, encodedMetadata);\n\n  return outputImage;\n}\n","/**\n * A no-op logger\n */\nclass DummyLogger {\n  log() {}\n\n  debug() {}\n\n  info() {}\n\n  warn() {}\n\n  error() {}\n\n  time() {}\n\n  timeEnd() {}\n}\n\nlet LOGGER = new DummyLogger();\n\n/**\n *\n * @param {object} logger the new logger. e.g `console`\n */\nexport function setLogger(logger = new DummyLogger()) {\n  LOGGER = logger;\n}\n\nexport function debug(...args) {\n  return LOGGER.debug(...args);\n}\n\nexport function log(...args) {\n  return LOGGER.log(...args);\n}\n\nexport function info(...args) {\n  return LOGGER.info(...args);\n}\n\nexport function warn(...args) {\n  return LOGGER.warn(...args);\n}\n\nexport function error(...args) {\n  return LOGGER.error(...args);\n}\n\nexport function time(...args) {\n  return LOGGER.time(...args);\n}\n\nexport function timeEnd(...args) {\n  return LOGGER.timeEnd(...args);\n}\n","function decodeRowAcc(row, stride) {\n  let length = row.length - stride;\n  let offset = 0;\n  do {\n    for (let i = stride; i > 0; i--) {\n      row[offset + stride] += row[offset];\n      offset++;\n    }\n\n    length -= stride;\n  } while (length > 0);\n}\n\nfunction decodeRowFloatingPoint(row, stride, bytesPerSample) {\n  let index = 0;\n  let count = row.length;\n  const wc = count / bytesPerSample;\n\n  while (count > stride) {\n    for (let i = stride; i > 0; --i) {\n      row[index + stride] += row[index];\n      ++index;\n    }\n    count -= stride;\n  }\n\n  const copy = row.slice();\n  for (let i = 0; i < wc; ++i) {\n    for (let b = 0; b < bytesPerSample; ++b) {\n      row[(bytesPerSample * i) + b] = copy[((bytesPerSample - b - 1) * wc) + i];\n    }\n  }\n}\n\nexport function applyPredictor(block, predictor, width, height, bitsPerSample,\n  planarConfiguration) {\n  if (!predictor || predictor === 1) {\n    return block;\n  }\n\n  for (let i = 0; i < bitsPerSample.length; ++i) {\n    if (bitsPerSample[i] % 8 !== 0) {\n      throw new Error('When decoding with predictor, only multiple of 8 bits are supported.');\n    }\n    if (bitsPerSample[i] !== bitsPerSample[0]) {\n      throw new Error('When decoding with predictor, all samples must have the same size.');\n    }\n  }\n\n  const bytesPerSample = bitsPerSample[0] / 8;\n  const stride = planarConfiguration === 2 ? 1 : bitsPerSample.length;\n\n  for (let i = 0; i < height; ++i) {\n    // Last strip will be truncated if height % stripHeight != 0\n    if (i * stride * width * bytesPerSample >= block.byteLength) {\n      break;\n    }\n    let row;\n    if (predictor === 2) { // horizontal prediction\n      switch (bitsPerSample[0]) {\n        case 8:\n          row = new Uint8Array(\n            block, i * stride * width * bytesPerSample, stride * width * bytesPerSample,\n          );\n          break;\n        case 16:\n          row = new Uint16Array(\n            block, i * stride * width * bytesPerSample, stride * width * bytesPerSample / 2,\n          );\n          break;\n        case 32:\n          row = new Uint32Array(\n            block, i * stride * width * bytesPerSample, stride * width * bytesPerSample / 4,\n          );\n          break;\n        default:\n          throw new Error(`Predictor 2 not allowed with ${bitsPerSample[0]} bits per sample.`);\n      }\n      decodeRowAcc(row, stride, bytesPerSample);\n    } else if (predictor === 3) { // horizontal floating point\n      row = new Uint8Array(\n        block, i * stride * width * bytesPerSample, stride * width * bytesPerSample,\n      );\n      decodeRowFloatingPoint(row, stride, bytesPerSample);\n    }\n  }\n  return block;\n}\n","import { applyPredictor } from '../predictor.js';\n\nexport default class BaseDecoder {\n  async decode(fileDirectory, buffer) {\n    const decoded = await this.decodeBlock(buffer);\n    const predictor = fileDirectory.Predictor || 1;\n    if (predictor !== 1) {\n      const isTiled = !fileDirectory.StripOffsets;\n      const tileWidth = isTiled ? fileDirectory.TileWidth : fileDirectory.ImageWidth;\n      const tileHeight = isTiled ? fileDirectory.TileLength : (\n        fileDirectory.RowsPerStrip || fileDirectory.ImageLength\n      );\n      return applyPredictor(\n        decoded, predictor, tileWidth, tileHeight, fileDirectory.BitsPerSample,\n        fileDirectory.PlanarConfiguration,\n      );\n    }\n    return decoded;\n  }\n}\n","/** @module geotiff */\nimport GeoTIFFImage from './geotiffimage.js';\nimport DataView64 from './dataview64.js';\nimport DataSlice from './dataslice.js';\nimport Pool from './pool.js';\n\nimport { makeRemoteSource, makeCustomSource } from './source/remote.js';\nimport { makeBufferSource } from './source/arraybuffer.js';\nimport { makeFileReaderSource } from './source/filereader.js';\nimport { makeFileSource } from './source/file.js';\nimport { BaseClient, BaseResponse } from './source/client/base.js';\n\nimport { fieldTypes, fieldTagNames, arrayFields, geoKeyNames } from './globals.js';\nimport { writeGeotiff } from './geotiffwriter.js';\nimport * as globals from './globals.js';\nimport * as rgb from './rgb.js';\nimport { getDecoder, addDecoder } from './compression/index.js';\nimport { setLogger } from './logging.js';\n\nexport { globals };\nexport { rgb };\nexport { default as BaseDecoder } from './compression/basedecoder.js';\nexport { getDecoder, addDecoder };\nexport { setLogger };\n\n/**\n * @typedef {Uint8Array | Int8Array | Uint16Array | Int16Array | Uint32Array | Int32Array | Float32Array | Float64Array}\n * TypedArray\n */\n\n/**\n * @typedef {{ height:number, width: number }} Dimensions\n */\n\n/**\n * The autogenerated docs are a little confusing here. The effective type is:\n *\n * `TypedArray & { height: number; width: number}`\n * @typedef {TypedArray & Dimensions} TypedArrayWithDimensions\n */\n\n/**\n * The autogenerated docs are a little confusing here. The effective type is:\n *\n * `TypedArray[] & { height: number; width: number}`\n * @typedef {TypedArray[] & Dimensions} TypedArrayArrayWithDimensions\n */\n\n/**\n *  The autogenerated docs are a little confusing here. The effective type is:\n *\n * `(TypedArray | TypedArray[]) & { height: number; width: number}`\n * @typedef {TypedArrayWithDimensions | TypedArrayArrayWithDimensions} ReadRasterResult\n */\n\nfunction getFieldTypeLength(fieldType) {\n  switch (fieldType) {\n    case fieldTypes.BYTE: case fieldTypes.ASCII: case fieldTypes.SBYTE: case fieldTypes.UNDEFINED:\n      return 1;\n    case fieldTypes.SHORT: case fieldTypes.SSHORT:\n      return 2;\n    case fieldTypes.LONG: case fieldTypes.SLONG: case fieldTypes.FLOAT: case fieldTypes.IFD:\n      return 4;\n    case fieldTypes.RATIONAL: case fieldTypes.SRATIONAL: case fieldTypes.DOUBLE:\n    case fieldTypes.LONG8: case fieldTypes.SLONG8: case fieldTypes.IFD8:\n      return 8;\n    default:\n      throw new RangeError(`Invalid field type: ${fieldType}`);\n  }\n}\n\nfunction parseGeoKeyDirectory(fileDirectory) {\n  const rawGeoKeyDirectory = fileDirectory.GeoKeyDirectory;\n  if (!rawGeoKeyDirectory) {\n    return null;\n  }\n\n  const geoKeyDirectory = {};\n  for (let i = 4; i <= rawGeoKeyDirectory[3] * 4; i += 4) {\n    const key = geoKeyNames[rawGeoKeyDirectory[i]];\n    const location = (rawGeoKeyDirectory[i + 1])\n      ? (fieldTagNames[rawGeoKeyDirectory[i + 1]]) : null;\n    const count = rawGeoKeyDirectory[i + 2];\n    const offset = rawGeoKeyDirectory[i + 3];\n\n    let value = null;\n    if (!location) {\n      value = offset;\n    } else {\n      value = fileDirectory[location];\n      if (typeof value === 'undefined' || value === null) {\n        throw new Error(`Could not get value of geoKey '${key}'.`);\n      } else if (typeof value === 'string') {\n        value = value.substring(offset, offset + count - 1);\n      } else if (value.subarray) {\n        value = value.subarray(offset, offset + count);\n        if (count === 1) {\n          value = value[0];\n        }\n      }\n    }\n    geoKeyDirectory[key] = value;\n  }\n  return geoKeyDirectory;\n}\n\nfunction getValues(dataSlice, fieldType, count, offset) {\n  let values = null;\n  let readMethod = null;\n  const fieldTypeLength = getFieldTypeLength(fieldType);\n\n  switch (fieldType) {\n    case fieldTypes.BYTE: case fieldTypes.ASCII: case fieldTypes.UNDEFINED:\n      values = new Uint8Array(count); readMethod = dataSlice.readUint8;\n      break;\n    case fieldTypes.SBYTE:\n      values = new Int8Array(count); readMethod = dataSlice.readInt8;\n      break;\n    case fieldTypes.SHORT:\n      values = new Uint16Array(count); readMethod = dataSlice.readUint16;\n      break;\n    case fieldTypes.SSHORT:\n      values = new Int16Array(count); readMethod = dataSlice.readInt16;\n      break;\n    case fieldTypes.LONG: case fieldTypes.IFD:\n      values = new Uint32Array(count); readMethod = dataSlice.readUint32;\n      break;\n    case fieldTypes.SLONG:\n      values = new Int32Array(count); readMethod = dataSlice.readInt32;\n      break;\n    case fieldTypes.LONG8: case fieldTypes.IFD8:\n      values = new Array(count); readMethod = dataSlice.readUint64;\n      break;\n    case fieldTypes.SLONG8:\n      values = new Array(count); readMethod = dataSlice.readInt64;\n      break;\n    case fieldTypes.RATIONAL:\n      values = new Uint32Array(count * 2); readMethod = dataSlice.readUint32;\n      break;\n    case fieldTypes.SRATIONAL:\n      values = new Int32Array(count * 2); readMethod = dataSlice.readInt32;\n      break;\n    case fieldTypes.FLOAT:\n      values = new Float32Array(count); readMethod = dataSlice.readFloat32;\n      break;\n    case fieldTypes.DOUBLE:\n      values = new Float64Array(count); readMethod = dataSlice.readFloat64;\n      break;\n    default:\n      throw new RangeError(`Invalid field type: ${fieldType}`);\n  }\n\n  // normal fields\n  if (!(fieldType === fieldTypes.RATIONAL || fieldType === fieldTypes.SRATIONAL)) {\n    for (let i = 0; i < count; ++i) {\n      values[i] = readMethod.call(\n        dataSlice, offset + (i * fieldTypeLength),\n      );\n    }\n  } else { // RATIONAL or SRATIONAL\n    for (let i = 0; i < count; i += 2) {\n      values[i] = readMethod.call(\n        dataSlice, offset + (i * fieldTypeLength),\n      );\n      values[i + 1] = readMethod.call(\n        dataSlice, offset + ((i * fieldTypeLength) + 4),\n      );\n    }\n  }\n\n  if (fieldType === fieldTypes.ASCII) {\n    return new TextDecoder('utf-8').decode(values);\n  }\n  return values;\n}\n\n/**\n * Data class to store the parsed file directory, geo key directory and\n * offset to the next IFD\n */\nclass ImageFileDirectory {\n  constructor(fileDirectory, geoKeyDirectory, nextIFDByteOffset) {\n    this.fileDirectory = fileDirectory;\n    this.geoKeyDirectory = geoKeyDirectory;\n    this.nextIFDByteOffset = nextIFDByteOffset;\n  }\n}\n\n/**\n * Error class for cases when an IFD index was requested, that does not exist\n * in the file.\n */\nclass GeoTIFFImageIndexError extends Error {\n  constructor(index) {\n    super(`No image at index ${index}`);\n    this.index = index;\n  }\n}\n\nclass GeoTIFFBase {\n  /**\n   * (experimental) Reads raster data from the best fitting image. This function uses\n   * the image with the lowest resolution that is still a higher resolution than the\n   * requested resolution.\n   * When specified, the `bbox` option is translated to the `window` option and the\n   * `resX` and `resY` to `width` and `height` respectively.\n   * Then, the [readRasters]{@link GeoTIFFImage#readRasters} method of the selected\n   * image is called and the result returned.\n   * @see GeoTIFFImage.readRasters\n   * @param {import('./geotiffimage').ReadRasterOptions} [options={}] optional parameters\n   * @returns {Promise<ReadRasterResult>} the decoded array(s), with `height` and `width`, as a promise\n   */\n  async readRasters(options = {}) {\n    const { window: imageWindow, width, height } = options;\n    let { resX, resY, bbox } = options;\n\n    const firstImage = await this.getImage();\n    let usedImage = firstImage;\n    const imageCount = await this.getImageCount();\n    const imgBBox = firstImage.getBoundingBox();\n\n    if (imageWindow && bbox) {\n      throw new Error('Both \"bbox\" and \"window\" passed.');\n    }\n\n    // if width/height is passed, transform it to resolution\n    if (width || height) {\n      // if we have an image window (pixel coordinates), transform it to a BBox\n      // using the origin/resolution of the first image.\n      if (imageWindow) {\n        const [oX, oY] = firstImage.getOrigin();\n        const [rX, rY] = firstImage.getResolution();\n\n        bbox = [\n          oX + (imageWindow[0] * rX),\n          oY + (imageWindow[1] * rY),\n          oX + (imageWindow[2] * rX),\n          oY + (imageWindow[3] * rY),\n        ];\n      }\n\n      // if we have a bbox (or calculated one)\n\n      const usedBBox = bbox || imgBBox;\n\n      if (width) {\n        if (resX) {\n          throw new Error('Both width and resX passed');\n        }\n        resX = (usedBBox[2] - usedBBox[0]) / width;\n      }\n      if (height) {\n        if (resY) {\n          throw new Error('Both width and resY passed');\n        }\n        resY = (usedBBox[3] - usedBBox[1]) / height;\n      }\n    }\n\n    // if resolution is set or calculated, try to get the image with the worst acceptable resolution\n    if (resX || resY) {\n      const allImages = [];\n      for (let i = 0; i < imageCount; ++i) {\n        const image = await this.getImage(i);\n        const { SubfileType: subfileType, NewSubfileType: newSubfileType } = image.fileDirectory;\n        if (i === 0 || subfileType === 2 || newSubfileType & 1) {\n          allImages.push(image);\n        }\n      }\n\n      allImages.sort((a, b) => a.getWidth() - b.getWidth());\n      for (let i = 0; i < allImages.length; ++i) {\n        const image = allImages[i];\n        const imgResX = (imgBBox[2] - imgBBox[0]) / image.getWidth();\n        const imgResY = (imgBBox[3] - imgBBox[1]) / image.getHeight();\n\n        usedImage = image;\n        if ((resX && resX > imgResX) || (resY && resY > imgResY)) {\n          break;\n        }\n      }\n    }\n\n    let wnd = imageWindow;\n    if (bbox) {\n      const [oX, oY] = firstImage.getOrigin();\n      const [imageResX, imageResY] = usedImage.getResolution(firstImage);\n\n      wnd = [\n        Math.round((bbox[0] - oX) / imageResX),\n        Math.round((bbox[1] - oY) / imageResY),\n        Math.round((bbox[2] - oX) / imageResX),\n        Math.round((bbox[3] - oY) / imageResY),\n      ];\n      wnd = [\n        Math.min(wnd[0], wnd[2]),\n        Math.min(wnd[1], wnd[3]),\n        Math.max(wnd[0], wnd[2]),\n        Math.max(wnd[1], wnd[3]),\n      ];\n    }\n\n    return usedImage.readRasters({ ...options, window: wnd });\n  }\n}\n\n/**\n * @typedef {Object} GeoTIFFOptions\n * @property {boolean} [cache=false] whether or not decoded tiles shall be cached.\n */\n\n/**\n * The abstraction for a whole GeoTIFF file.\n * @augments GeoTIFFBase\n */\nclass GeoTIFF extends GeoTIFFBase {\n  /**\n   * @constructor\n   * @param {*} source The datasource to read from.\n   * @param {boolean} littleEndian Whether the image uses little endian.\n   * @param {boolean} bigTiff Whether the image uses bigTIFF conventions.\n   * @param {number} firstIFDOffset The numeric byte-offset from the start of the image\n   *                                to the first IFD.\n   * @param {GeoTIFFOptions} [options] further options.\n   */\n  constructor(source, littleEndian, bigTiff, firstIFDOffset, options = {}) {\n    super();\n    this.source = source;\n    this.littleEndian = littleEndian;\n    this.bigTiff = bigTiff;\n    this.firstIFDOffset = firstIFDOffset;\n    this.cache = options.cache || false;\n    this.ifdRequests = [];\n    this.ghostValues = null;\n  }\n\n  async getSlice(offset, size) {\n    const fallbackSize = this.bigTiff ? 4048 : 1024;\n    return new DataSlice(\n      (await this.source.fetch([{\n        offset,\n        length: typeof size !== 'undefined' ? size : fallbackSize,\n      }]))[0],\n      offset,\n      this.littleEndian,\n      this.bigTiff,\n    );\n  }\n\n  /**\n   * Instructs to parse an image file directory at the given file offset.\n   * As there is no way to ensure that a location is indeed the start of an IFD,\n   * this function must be called with caution (e.g only using the IFD offsets from\n   * the headers or other IFDs).\n   * @param {number} offset the offset to parse the IFD at\n   * @returns {Promise<ImageFileDirectory>} the parsed IFD\n   */\n  async parseFileDirectoryAt(offset) {\n    const entrySize = this.bigTiff ? 20 : 12;\n    const offsetSize = this.bigTiff ? 8 : 2;\n\n    let dataSlice = await this.getSlice(offset);\n    const numDirEntries = this.bigTiff\n      ? dataSlice.readUint64(offset)\n      : dataSlice.readUint16(offset);\n\n    // if the slice does not cover the whole IFD, request a bigger slice, where the\n    // whole IFD fits: num of entries + n x tag length + offset to next IFD\n    const byteSize = (numDirEntries * entrySize) + (this.bigTiff ? 16 : 6);\n    if (!dataSlice.covers(offset, byteSize)) {\n      dataSlice = await this.getSlice(offset, byteSize);\n    }\n\n    const fileDirectory = {};\n\n    // loop over the IFD and create a file directory object\n    let i = offset + (this.bigTiff ? 8 : 2);\n    for (let entryCount = 0; entryCount < numDirEntries; i += entrySize, ++entryCount) {\n      const fieldTag = dataSlice.readUint16(i);\n      const fieldType = dataSlice.readUint16(i + 2);\n      const typeCount = this.bigTiff\n        ? dataSlice.readUint64(i + 4)\n        : dataSlice.readUint32(i + 4);\n\n      let fieldValues;\n      let value;\n      const fieldTypeLength = getFieldTypeLength(fieldType);\n      const valueOffset = i + (this.bigTiff ? 12 : 8);\n\n      // check whether the value is directly encoded in the tag or refers to a\n      // different external byte range\n      if (fieldTypeLength * typeCount <= (this.bigTiff ? 8 : 4)) {\n        fieldValues = getValues(dataSlice, fieldType, typeCount, valueOffset);\n      } else {\n        // resolve the reference to the actual byte range\n        const actualOffset = dataSlice.readOffset(valueOffset);\n        const length = getFieldTypeLength(fieldType) * typeCount;\n\n        // check, whether we actually cover the referenced byte range; if not,\n        // request a new slice of bytes to read from it\n        if (dataSlice.covers(actualOffset, length)) {\n          fieldValues = getValues(dataSlice, fieldType, typeCount, actualOffset);\n        } else {\n          const fieldDataSlice = await this.getSlice(actualOffset, length);\n          fieldValues = getValues(fieldDataSlice, fieldType, typeCount, actualOffset);\n        }\n      }\n\n      // unpack single values from the array\n      if (typeCount === 1 && arrayFields.indexOf(fieldTag) === -1\n        && !(fieldType === fieldTypes.RATIONAL || fieldType === fieldTypes.SRATIONAL)) {\n        value = fieldValues[0];\n      } else {\n        value = fieldValues;\n      }\n\n      // write the tags value to the file directly\n      fileDirectory[fieldTagNames[fieldTag]] = value;\n    }\n    const geoKeyDirectory = parseGeoKeyDirectory(fileDirectory);\n    const nextIFDByteOffset = dataSlice.readOffset(\n      offset + offsetSize + (entrySize * numDirEntries),\n    );\n\n    return new ImageFileDirectory(\n      fileDirectory,\n      geoKeyDirectory,\n      nextIFDByteOffset,\n    );\n  }\n\n  async requestIFD(index) {\n    // see if we already have that IFD index requested.\n    if (this.ifdRequests[index]) {\n      // attach to an already requested IFD\n      return this.ifdRequests[index];\n    } else if (index === 0) {\n      // special case for index 0\n      this.ifdRequests[index] = this.parseFileDirectoryAt(this.firstIFDOffset);\n      return this.ifdRequests[index];\n    } else if (!this.ifdRequests[index - 1]) {\n      // if the previous IFD was not yet loaded, load that one first\n      // this is the recursive call.\n      try {\n        this.ifdRequests[index - 1] = this.requestIFD(index - 1);\n      } catch (e) {\n        // if the previous one already was an index error, rethrow\n        // with the current index\n        if (e instanceof GeoTIFFImageIndexError) {\n          throw new GeoTIFFImageIndexError(index);\n        }\n        // rethrow anything else\n        throw e;\n      }\n    }\n    // if the previous IFD was loaded, we can finally fetch the one we are interested in.\n    // we need to wrap this in an IIFE, otherwise this.ifdRequests[index] would be delayed\n    this.ifdRequests[index] = (async () => {\n      const previousIfd = await this.ifdRequests[index - 1];\n      if (previousIfd.nextIFDByteOffset === 0) {\n        throw new GeoTIFFImageIndexError(index);\n      }\n      return this.parseFileDirectoryAt(previousIfd.nextIFDByteOffset);\n    })();\n    return this.ifdRequests[index];\n  }\n\n  /**\n   * Get the n-th internal subfile of an image. By default, the first is returned.\n   *\n   * @param {number} [index=0] the index of the image to return.\n   * @returns {Promise<GeoTIFFImage>} the image at the given index\n   */\n  async getImage(index = 0) {\n    const ifd = await this.requestIFD(index);\n    return new GeoTIFFImage(\n      ifd.fileDirectory, ifd.geoKeyDirectory,\n      this.dataView, this.littleEndian, this.cache, this.source,\n    );\n  }\n\n  /**\n   * Returns the count of the internal subfiles.\n   *\n   * @returns {Promise<number>} the number of internal subfile images\n   */\n  async getImageCount() {\n    let index = 0;\n    // loop until we run out of IFDs\n    let hasNext = true;\n    while (hasNext) {\n      try {\n        await this.requestIFD(index);\n        ++index;\n      } catch (e) {\n        if (e instanceof GeoTIFFImageIndexError) {\n          hasNext = false;\n        } else {\n          throw e;\n        }\n      }\n    }\n    return index;\n  }\n\n  /**\n   * Get the values of the COG ghost area as a parsed map.\n   * See https://gdal.org/drivers/raster/cog.html#header-ghost-area for reference\n   * @returns {Promise<Object>} the parsed ghost area or null, if no such area was found\n   */\n  async getGhostValues() {\n    const offset = this.bigTiff ? 16 : 8;\n    if (this.ghostValues) {\n      return this.ghostValues;\n    }\n    const detectionString = 'GDAL_STRUCTURAL_METADATA_SIZE=';\n    const heuristicAreaSize = detectionString.length + 100;\n    let slice = await this.getSlice(offset, heuristicAreaSize);\n    if (detectionString === getValues(slice, fieldTypes.ASCII, detectionString.length, offset)) {\n      const valuesString = getValues(slice, fieldTypes.ASCII, heuristicAreaSize, offset);\n      const firstLine = valuesString.split('\\n')[0];\n      const metadataSize = Number(firstLine.split('=')[1].split(' ')[0]) + firstLine.length;\n      if (metadataSize > heuristicAreaSize) {\n        slice = await this.getSlice(offset, metadataSize);\n      }\n      const fullString = getValues(slice, fieldTypes.ASCII, metadataSize, offset);\n      this.ghostValues = {};\n      fullString\n        .split('\\n')\n        .filter((line) => line.length > 0)\n        .map((line) => line.split('='))\n        .forEach(([key, value]) => {\n          this.ghostValues[key] = value;\n        });\n    }\n    return this.ghostValues;\n  }\n\n  /**\n   * Parse a (Geo)TIFF file from the given source.\n   *\n   * @param {*} source The source of data to parse from.\n   * @param {GeoTIFFOptions} [options] Additional options.\n   * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n   *                               to be aborted\n   */\n  static async fromSource(source, options, signal) {\n    const headerData = (await source.fetch([{ offset: 0, length: 1024 }], signal))[0];\n    const dataView = new DataView64(headerData);\n\n    const BOM = dataView.getUint16(0, 0);\n    let littleEndian;\n    if (BOM === 0x4949) {\n      littleEndian = true;\n    } else if (BOM === 0x4D4D) {\n      littleEndian = false;\n    } else {\n      throw new TypeError('Invalid byte order value.');\n    }\n\n    const magicNumber = dataView.getUint16(2, littleEndian);\n    let bigTiff;\n    if (magicNumber === 42) {\n      bigTiff = false;\n    } else if (magicNumber === 43) {\n      bigTiff = true;\n      const offsetByteSize = dataView.getUint16(4, littleEndian);\n      if (offsetByteSize !== 8) {\n        throw new Error('Unsupported offset byte-size.');\n      }\n    } else {\n      throw new TypeError('Invalid magic number.');\n    }\n\n    const firstIFDOffset = bigTiff\n      ? dataView.getUint64(8, littleEndian)\n      : dataView.getUint32(4, littleEndian);\n    return new GeoTIFF(source, littleEndian, bigTiff, firstIFDOffset, options);\n  }\n\n  /**\n   * Closes the underlying file buffer\n   * N.B. After the GeoTIFF has been completely processed it needs\n   * to be closed but only if it has been constructed from a file.\n   */\n  close() {\n    if (typeof this.source.close === 'function') {\n      return this.source.close();\n    }\n    return false;\n  }\n}\n\nexport { GeoTIFF };\nexport default GeoTIFF;\n\n/**\n * Wrapper for GeoTIFF files that have external overviews.\n * @augments GeoTIFFBase\n */\nclass MultiGeoTIFF extends GeoTIFFBase {\n  /**\n   * Construct a new MultiGeoTIFF from a main and several overview files.\n   * @param {GeoTIFF} mainFile The main GeoTIFF file.\n   * @param {GeoTIFF[]} overviewFiles An array of overview files.\n   */\n  constructor(mainFile, overviewFiles) {\n    super();\n    this.mainFile = mainFile;\n    this.overviewFiles = overviewFiles;\n    this.imageFiles = [mainFile].concat(overviewFiles);\n\n    this.fileDirectoriesPerFile = null;\n    this.fileDirectoriesPerFileParsing = null;\n    this.imageCount = null;\n  }\n\n  async parseFileDirectoriesPerFile() {\n    const requests = [this.mainFile.parseFileDirectoryAt(this.mainFile.firstIFDOffset)]\n      .concat(this.overviewFiles.map((file) => file.parseFileDirectoryAt(file.firstIFDOffset)));\n\n    this.fileDirectoriesPerFile = await Promise.all(requests);\n    return this.fileDirectoriesPerFile;\n  }\n\n  /**\n   * Get the n-th internal subfile of an image. By default, the first is returned.\n   *\n   * @param {number} [index=0] the index of the image to return.\n   * @returns {Promise<GeoTIFFImage>} the image at the given index\n   */\n  async getImage(index = 0) {\n    await this.getImageCount();\n    await this.parseFileDirectoriesPerFile();\n    let visited = 0;\n    let relativeIndex = 0;\n    for (let i = 0; i < this.imageFiles.length; i++) {\n      const imageFile = this.imageFiles[i];\n      for (let ii = 0; ii < this.imageCounts[i]; ii++) {\n        if (index === visited) {\n          const ifd = await imageFile.requestIFD(relativeIndex);\n          return new GeoTIFFImage(\n            ifd.fileDirectory, ifd.geoKeyDirectory,\n            imageFile.dataView, imageFile.littleEndian, imageFile.cache, imageFile.source,\n          );\n        }\n        visited++;\n        relativeIndex++;\n      }\n      relativeIndex = 0;\n    }\n\n    throw new RangeError('Invalid image index');\n  }\n\n  /**\n   * Returns the count of the internal subfiles.\n   *\n   * @returns {Promise<number>} the number of internal subfile images\n   */\n  async getImageCount() {\n    if (this.imageCount !== null) {\n      return this.imageCount;\n    }\n    const requests = [this.mainFile.getImageCount()]\n      .concat(this.overviewFiles.map((file) => file.getImageCount()));\n    this.imageCounts = await Promise.all(requests);\n    this.imageCount = this.imageCounts.reduce((count, ifds) => count + ifds, 0);\n    return this.imageCount;\n  }\n}\n\nexport { MultiGeoTIFF };\n\n/**\n * Creates a new GeoTIFF from a remote URL.\n * @param {string} url The URL to access the image from\n * @param {object} [options] Additional options to pass to the source.\n *                           See {@link makeRemoteSource} for details.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nexport async function fromUrl(url, options = {}, signal) {\n  return GeoTIFF.fromSource(makeRemoteSource(url, options), signal);\n}\n\n/**\n * Creates a new GeoTIFF from a custom {@link BaseClient}.\n * @param {BaseClient} client The client.\n * @param {object} [options] Additional options to pass to the source.\n *                           See {@link makeRemoteSource} for details.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nexport async function fromCustomClient(client, options = {}, signal) {\n  return GeoTIFF.fromSource(makeCustomSource(client, options), signal);\n}\n\n/**\n * Construct a new GeoTIFF from an\n * [ArrayBuffer]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer}.\n * @param {ArrayBuffer} arrayBuffer The data to read the file from.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nexport async function fromArrayBuffer(arrayBuffer, signal) {\n  return GeoTIFF.fromSource(makeBufferSource(arrayBuffer), signal);\n}\n\n/**\n * Construct a GeoTIFF from a local file path. This uses the node\n * [filesystem API]{@link https://nodejs.org/api/fs.html} and is\n * not available on browsers.\n *\n * N.B. After the GeoTIFF has been completely processed it needs\n * to be closed but only if it has been constructed from a file.\n * @param {string} path The file path to read from.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nexport async function fromFile(path, signal) {\n  return GeoTIFF.fromSource(makeFileSource(path), signal);\n}\n\n/**\n * Construct a GeoTIFF from an HTML\n * [Blob]{@link https://developer.mozilla.org/en-US/docs/Web/API/Blob} or\n * [File]{@link https://developer.mozilla.org/en-US/docs/Web/API/File}\n * object.\n * @param {Blob|File} blob The Blob or File object to read from.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nexport async function fromBlob(blob, signal) {\n  return GeoTIFF.fromSource(makeFileReaderSource(blob), signal);\n}\n\n/**\n * Construct a MultiGeoTIFF from the given URLs.\n * @param {string} mainUrl The URL for the main file.\n * @param {string[]} overviewUrls An array of URLs for the overview images.\n * @param {Object} [options] Additional options to pass to the source.\n *                           See [makeRemoteSource]{@link module:source.makeRemoteSource}\n *                           for details.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<MultiGeoTIFF>} The resulting MultiGeoTIFF file.\n */\nexport async function fromUrls(mainUrl, overviewUrls = [], options = {}, signal) {\n  const mainFile = await GeoTIFF.fromSource(makeRemoteSource(mainUrl, options), signal);\n  const overviewFiles = await Promise.all(\n    overviewUrls.map((url) => GeoTIFF.fromSource(makeRemoteSource(url, options))),\n  );\n\n  return new MultiGeoTIFF(mainFile, overviewFiles);\n}\n\n/**\n * Main creating function for GeoTIFF files.\n * @param {(Array)} array of pixel values\n * @returns {metadata} metadata\n */\nexport function writeArrayBuffer(values, metadata) {\n  return writeGeotiff(values, metadata);\n}\n\nexport { Pool };\nexport { GeoTIFFImage };\nexport { BaseClient, BaseResponse };\n"],"file":"assets/geotiff-4EhtXGWf.js"}